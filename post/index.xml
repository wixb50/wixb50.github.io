<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Wixb blog</title>
    <link>http://wixb50.github.io/post/</link>
    <description>Recent content in Posts on Wixb blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wixb50@gmail.com (Wixb)</managingEditor>
    <webMaster>wixb50@gmail.com (Wixb)</webMaster>
    <copyright>(c) 2015 wixb.All rights reserved.</copyright>
    <lastBuildDate>Sat, 17 Sep 2016 10:38:38 +0800</lastBuildDate>
    <atom:link href="http://wixb50.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>docker1.12 集群实践方案</title>
      <link>http://wixb50.github.io/2016/09/17/docker1.12-%E9%9B%86%E7%BE%A4%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sat, 17 Sep 2016 10:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/09/17/docker1.12-%E9%9B%86%E7%BE%A4%E5%AE%9E%E8%B7%B5%E6%96%B9%E6%A1%88/</guid>
      <description>

&lt;!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#前言&#34;&gt;&lt;a href=&#34;#&#34;&gt;前言&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker私有仓库&#34;&gt;docker私有仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker-swarm&#34;&gt;Docker swarm&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker-service&#34;&gt;docker service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#add-on&#34;&gt;add on&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#consulregistrator服务注册&#34;&gt;consul、registrator服务注册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#graylog-日志收集&#34;&gt;graylog 日志收集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#参考&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h1 id=&#34;前言&#34;&gt;&lt;a href=&#34;#&#34;&gt;前言&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;Docker 1.12将原先独立的项目&lt;code&gt;docker swarm&lt;/code&gt;已经集成进自带的&lt;code&gt;docker engine&lt;/code&gt;，并为集群方案提供了整一套的跨主机集群、灵活调度、高可用性的方案，同时引入service的概念，增加了服务创建的简易性、灵活性，还拥有服务注册、服务发现、服务自动负载均衡等特性。&lt;/p&gt;

&lt;p&gt;在本docker集群方案中，先介绍私有仓库的概念，作为集群服务部署的基础；然后利用docker提供的官方的集群方案swarm搭建集群；最后补充一些其他方案满足整集群的监控，日志收集等方面。&lt;/p&gt;

&lt;h1 id=&#34;docker私有仓库&#34;&gt;docker私有仓库&lt;/h1&gt;

&lt;p&gt;仓库（Repository）是集中存放镜像文件的场所。仓库分为公开仓库（Public）和私有仓库（Private）两种形式。&lt;/p&gt;

&lt;p&gt;最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。&lt;/p&gt;

&lt;p&gt;当需要加快service的更新速度的时候，就需要在局域网内拥有自建的私有仓库，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。&lt;/p&gt;

&lt;h1 id=&#34;docker-swarm&#34;&gt;Docker swarm&lt;/h1&gt;

&lt;p&gt;在docker1.12版本中不再试独立的项目，而集成在docker engine中，对于创建和管理集群都是非常方便的。&lt;/p&gt;

&lt;p&gt;初始化集群master节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker swarm init
Swarm initialized: current node (0khsh2muxte9lkh584btlhgkv) is now a manager.

To add a worker to this swarm, run the following command:
    docker swarm join \
    --token SWMTKN-1-3re5jcwzt0yjx5h5gtxgaspgib0gxrs75peyiwufbk9bzr4nmh-f496phvvqbtekc21lulndjnfy \
    192.168.65.2:2377

To add a manager to this swarm, run the following command:
    docker swarm join \
    --token SWMTKN-1-3re5jcwzt0yjx5h5gtxgaspgib0gxrs75peyiwufbk9bzr4nmh-5beo6o66ep6p9yhqh7m2f0h8y \
    192.168.65.2:2377
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在同局域网中worker节点执行上述提供的加入集群命令即可。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;docker swarm集群最小只需一个master节点即可，同时也可以多个manager、多个worker节点；所以为了保证集群的高可用性，可创建多几个manager节点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;docker-service&#34;&gt;docker service&lt;/h2&gt;

&lt;p&gt;docker将所有部署的应用都抽象为service，在新建集群之后需要在集群中部署服务，这时候就要利用service命令了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建service&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service create --name gateway --publish 80:80 --replicas 2 nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.在创建service之后，master会自动下发任务给集群节点，并生成指定数量的服务容器replicas；2.同时由于swarm采用的是overlay(跨主机网络)，在swarm内部会自动将该服务name注册到内部的注册中心；3.如该服务是提供给内部系统调用的话，只需要访问其service name即可自动转发到相应服务，这样就避免了难记又易变得ip地址。4.并且由于service是可能部署多个replicas的，所以swarm也能达到一定的负载均衡的作用。5.我们就只需要对提供给外部网络访问的服务暴露指定的端口&lt;code&gt;--publish 80:80&lt;/code&gt;就可以了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;scale service数量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker service scale gateway=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时如果由于异常容器退出的话，swarm自带的 &lt;strong&gt;安全检查&lt;/strong&gt; 会删除原来的失败的容器，并重新启动一个新的，保证服务的replicas数量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;service滚动更新&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们代码有更新需要重新部署的时候，重新构建镜像push到仓库(不同tag版本命名)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker service update --image new-image-name gateway
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;service更新的时候如果image不一样，则service会自动根据新的image拉取镜像，进行滚动更新。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;删除service
&lt;code&gt;
$ docker service rm gateway
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;add-on&#34;&gt;add on&lt;/h1&gt;

&lt;h2 id=&#34;consul-registrator服务注册&#34;&gt;consul、registrator服务注册&lt;/h2&gt;

&lt;p&gt;由于swarm内部的服务注册和发现机制是内部的，不对外开放的，而且不是通过service启动的容器，swarm是发现不了的，所以为了监控整个集群的所有容器，我们可以自己搭建一套。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;consul注册中心&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;consul用户保存集群中注册的所有容器，提供一个信息存储中心，只需要搭建一个即可(也可部署集群)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -h node \
   --name=consul \
   -p 8500:8500 \
   -p 8600:53/udp \
   progrium/consul:latest \
   -server \
   -bootstrap \
   -advertise $DOCKER_IP \
   -log-level debug
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过浏览器能够访问$DOCKER_IP:8500，你将在控制面板上看到Consul中已经注册的所有服务。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;registrator注册组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该组件Registrator配置好相应的环境变量并将这个容器注册到Consul上。它会监控本机的docker进程，如果容器开启会自动注册到consul，关闭则自动移除。所以需要在集群的每台主机上配置安装下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d \
   --name=registrator \
   --net=host \
   -v /var/run/docker.sock:/tmp/docker.sock \
   gliderlabs/registrator:latest \
   consul://$DOCKER_IP:8500
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;graylog-日志收集&#34;&gt;graylog 日志收集&lt;/h2&gt;

&lt;p&gt;由于服务都是集群部署，上线之后直接使用&lt;code&gt;docker logs&lt;/code&gt;命令查看容器日志是不合理的，同时问题排查也相当困难。&lt;/p&gt;

&lt;p&gt;所以搭建一个统一的日志收集器用以收集容器所有日志。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d --name graylog -p 9000:9000 -p 12201:12201/udp graylog2/allinone:latest
// 在需要收集日志的容器或者service启动命令中加入(docker官方推荐)
--log-driver=gelf --log-opt gelf-address=udp://192.168.0.42:12201
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对于直接&lt;code&gt;stdout&lt;/code&gt;的日志将都会被发送到graylog中。至于graylog有什么强大功能就需要自己去发掘了。&lt;/p&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dockone.io/article/272&#34;&gt;http://dockone.io/article/272&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;集群项目
   * Docker compose、Docker machine、Docker swarm
   * Kubernetes&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>docker入门</title>
      <link>http://wixb50.github.io/2016/06/17/docker%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 17 Jun 2016 19:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/06/17/docker%E5%85%A5%E9%97%A8/</guid>
      <description>

&lt;!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:0 orderedList:0 --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#前言&#34;&gt;&lt;a href=&#34;#&#34;&gt;前言&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#基本概念&#34;&gt;基本概念&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#镜像&#34;&gt;镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#容器&#34;&gt;容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#仓库&#34;&gt;仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#安装&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#常用命令&#34;&gt;常用命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#镜像命令&#34;&gt;镜像命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#容器命令&#34;&gt;容器命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker进阶&#34;&gt;Docker进阶&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#数据卷&#34;&gt;数据卷&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#主机容器数据共享&#34;&gt;主机容器数据共享&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#数据卷容器&#34;&gt;数据卷容器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dockerfile&#34;&gt;Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /TOC --&gt;

&lt;h1 id=&#34;前言:11cc16163169598471edee7a60af0f73&#34;&gt;&lt;a href=&#34;#&#34;&gt;前言&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt; 是个开源项目，它彻底释放了虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本，同时让应用的部署、测试和分发都变得前所未有的高效和轻松。Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;

&lt;p&gt;如果把虚拟化比做OS，则Docker是OS上的再一层抽象，它运行的容器可以看作一个进程级别的虚拟机。启动、运行、安装都是只通过一个命令就能解决。对于搭建集群、系统CI和不可变基础设施是非常有利的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker简单原理&lt;/strong&gt; Docker只是管理运行轻量级容器的工具，容器是基于Linux内核技术包括namespace，cgroup，叠加文件系统如AUFS，工具提供运行应用，打包应用，分发应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker影响&lt;/strong&gt; Docker成为最火热，甚至最具颠覆性的技术之一。相对于传统的云服务提供商(Iaas,Paas,Saas)，提出了一种全新的Caas(容器即服务)，国内比较领先的有DaoCloud、时速云等。Docker提出了“Build once，Run anywhere。&lt;/p&gt;

&lt;h1 id=&#34;基本概念:11cc16163169598471edee7a60af0f73&#34;&gt;基本概念&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;http://www.otokaze.cn/wp-content/uploads/2016/09/docker_vs_vm.png&#34; alt=&#34;原理图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Docker 包括三个基本概念&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;镜像（Image）&lt;/li&gt;
&lt;li&gt;容器（Container）&lt;/li&gt;
&lt;li&gt;仓库（Repository）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解了这三个概念，就理解了 Docker 的整个生命周期。&lt;/p&gt;

&lt;h2 id=&#34;镜像:11cc16163169598471edee7a60af0f73&#34;&gt;镜像&lt;/h2&gt;

&lt;p&gt;Docker 镜像（Image）就是一个只读的模板，相当于操作系统(OS)安装的Ghost。&lt;/p&gt;

&lt;p&gt;例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。&lt;/p&gt;

&lt;p&gt;镜像可以用来创建 Docker 容器。&lt;/p&gt;

&lt;p&gt;Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。&lt;/p&gt;

&lt;h2 id=&#34;容器:11cc16163169598471edee7a60af0f73&#34;&gt;容器&lt;/h2&gt;

&lt;p&gt;Docker 利用容器（Container）来运行应用。&lt;/p&gt;

&lt;p&gt;容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。同时容器也可以暴露相应的“端口”和挂载“容器卷”，分别用以网络和存储共享。&lt;/p&gt;

&lt;p&gt;可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。&lt;/p&gt;

&lt;h2 id=&#34;仓库:11cc16163169598471edee7a60af0f73&#34;&gt;仓库&lt;/h2&gt;

&lt;p&gt;仓库（Repository）是集中存放镜像文件的场所。&lt;/p&gt;

&lt;p&gt;仓库分为公开仓库（Public）和私有仓库（Private）两种形式。&lt;/p&gt;

&lt;p&gt;最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。&lt;/p&gt;

&lt;p&gt;国内的公开仓库包括 时速云 、网易云 等，可以提供大陆用户更稳定快速的访问。&lt;/p&gt;

&lt;p&gt;当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。&lt;/p&gt;

&lt;p&gt;*注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。&lt;/p&gt;

&lt;h2 id=&#34;安装:11cc16163169598471edee7a60af0f73&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Docker 目前只能安装在 64 位平台上，并且要求内核版本不低于 3.10，实际上内核越新越好，过低的内核版本容易造成功能的不稳定。&lt;/p&gt;

&lt;p&gt;快捷安装脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;常用命令:11cc16163169598471edee7a60af0f73&#34;&gt;常用命令&lt;/h1&gt;

&lt;h2 id=&#34;镜像命令:11cc16163169598471edee7a60af0f73&#34;&gt;镜像命令&lt;/h2&gt;

&lt;p&gt;获取镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker pull ubuntu:12.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载过程中，会输出获取镜像的每一层信息。
该命令实际上相当于 $ sudo docker pull registry.hub.docker.com/ubuntu:12.04 命令，即从注册服务器 registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。&lt;/p&gt;

&lt;p&gt;使用 docker images 显示本地已有的镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除本地的镜像，可以使用 docker rmi 命令。注意 docker rm 命令是移除容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker rmi training/sinatra
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;容器命令:11cc16163169598471edee7a60af0f73&#34;&gt;容器命令&lt;/h2&gt;

&lt;p&gt;基于一个images，新建并启动一个容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run ubuntu:14.04 /bin/echo &#39;Hello world&#39;
Hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有启动的容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有的容器(包括未启动的)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据容器id，或者name启动，重启，停止容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker start/restart {containerID|containerName}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run -d ubuntu:14.04 /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot;
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时容器会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果可以用docker logs 查看)。&lt;/p&gt;

&lt;p&gt;容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run -d -p 5000:5000 training/webapp python app.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口.&lt;/p&gt;

&lt;h1 id=&#34;docker进阶:11cc16163169598471edee7a60af0f73&#34;&gt;Docker进阶&lt;/h1&gt;

&lt;h2 id=&#34;数据卷:11cc16163169598471edee7a60af0f73&#34;&gt;数据卷&lt;/h2&gt;

&lt;p&gt;用于Docker 内部以及容器之间管理数据共享与存储。&lt;/p&gt;

&lt;h3 id=&#34;主机容器数据共享:11cc16163169598471edee7a60af0f73&#34;&gt;主机容器数据共享&lt;/h3&gt;

&lt;p&gt;挂载一个主机目录作为数据卷,使用 -v 标记也可以指定挂载一个本地主机的目录到容器中去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后对容器相应的目录更改便直接反映在主机中了。&lt;/p&gt;

&lt;h3 id=&#34;数据卷容器:11cc16163169598471edee7a60af0f73&#34;&gt;数据卷容器&lt;/h3&gt;

&lt;p&gt;数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。&lt;/p&gt;

&lt;p&gt;首先，创建一个命名的数据卷容器 dbdata：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，在其他容器中使用 &amp;ndash;volumes-from 来挂载 dbdata 容器中的数据卷。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run -d --volumes-from dbdata --name db1 training/postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dockerfile:11cc16163169598471edee7a60af0f73&#34;&gt;Dockerfile&lt;/h2&gt;

&lt;p&gt;docker 采用分层存储驱动，使用 Dockerfile 可以允许用户创建自定义的镜像。&lt;/p&gt;

&lt;p&gt;Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Base image to use, this must be set as the first line
FROM ubuntu

# Maintainer: docker_user &amp;lt;docker_user at email.com&amp;gt; (@docker_user)
MAINTAINER docker_user docker_user@email.com

# Commands to update the image
RUN echo &amp;quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&amp;quot; &amp;gt;&amp;gt; /etc/apt/sources.list
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y nginx
RUN echo &amp;quot;\ndaemon off;&amp;quot; &amp;gt;&amp;gt; /etc/nginx/nginx.conf

# Commands when creating a new container
CMD /usr/sbin/nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。&lt;/p&gt;

&lt;p&gt;后面则是镜像操作指令，例如 RUN 指令，RUN 指令将对镜像执行跟随的命令。每运行一条 RUN 指令，镜像添加新的一层，并提交。&lt;/p&gt;

&lt;p&gt;最后是 CMD 指令，来指定运行容器时的操作命令。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CentOS常用命令集合</title>
      <link>http://wixb50.github.io/2016/06/01/centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</link>
      <pubDate>Wed, 01 Jun 2016 10:07:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/06/01/centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</guid>
      <description>

&lt;h2 id=&#34;centos添加及删除用户&#34;&gt;CentOS添加及删除用户&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;adduser int # 新增用户
passwd int # 设置或者修改密码
chmod 740 /etc/sudoers # 设置超级管理员组配置文件可写
vim /etc/sudoers # 编辑文件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加int如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## Allow root to run any commands anywhere 
root    ALL=(ALL)   ALL
int ALL=(ALL)   ALL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;userdel test # 删除用户
userdel -f test # 删除用户及用户组
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>树莓派samba离线下载器</title>
      <link>http://wixb50.github.io/2016/05/24/%E6%A0%91%E8%8E%93%E6%B4%BEsamba%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%99%A8/</link>
      <pubDate>Tue, 24 May 2016 20:25:17 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/05/24/%E6%A0%91%E8%8E%93%E6%B4%BEsamba%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%99%A8/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;主要用samba实现局域网共享。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;apt安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install samba samba-common-bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件/etc/samba/smb.conf，在最后添加以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[raspi]                                   #共享文件的名称，将在网络上以此名称显示
        path = /mnt/myusbdrive                     #共享文件的路径
        valid users = pi             #允许访问的用户
        browseable = yes                  #允许浏览                                 
        public = yes                      #共享开放                                      
        writable = yes                    #可写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存后，重启 samba 服务，输入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/samba restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置密码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;smbpasswd –a pi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;连接&#34;&gt;连接&lt;/h2&gt;

&lt;p&gt;在&lt;code&gt;nautilus&lt;/code&gt;中选择连接到服务器，地址为&lt;code&gt;smb://192.168.1X.10X/&lt;/code&gt;，连接输入用户名密码即可。或者在windows上映射到网络驱动器，地址&lt;code&gt;\\192.1.1.1XX\{{你的目录}}&lt;/code&gt;即可连接。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>树莓派安装Gogs</title>
      <link>http://wixb50.github.io/2016/05/18/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85gogs/</link>
      <pubDate>Wed, 18 May 2016 14:25:17 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/05/18/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85gogs/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;本文主要介绍二进制安装方案，如果想用其他方法安装，请参考&lt;a href=&#34;https://gogs.io/docs&#34;&gt;官方文档&lt;/a&gt;;&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;所有的版本都支持 MySQL 和 PostgreSQL、SQLite作为数据库，针对你想要存放的位置建立好数据库服务器。&lt;/li&gt;
&lt;li&gt;在 &lt;a href=&#34;https://github.com/gogits/gogs/releases&#34;&gt;https://github.com/gogits/gogs/releases&lt;/a&gt; 下载号对应的二进制安装包，下载最新的rsapi*.zip即可，导入到树莓派中。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;新建用户&#34;&gt;新建用户&lt;/h2&gt;

&lt;p&gt;Gogs 默认以 git 用户运行，所以最好新建一个用户，要不然可能会出现你的主账户无法登录的问题。运行&lt;code&gt;sudo adduser git&lt;/code&gt;新建好用户，&lt;code&gt;su git&lt;/code&gt;以git用户身份登录。&lt;/p&gt;

&lt;h2 id=&#34;运行配置&#34;&gt;运行配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;解压压缩包。&lt;/li&gt;
&lt;li&gt;使用命令 cd 进入到刚刚创建的目录。&lt;/li&gt;
&lt;li&gt;执行命令 ./gogs web，然后，访问&lt;a href=&#34;http://IP:3000，填写服务器信息就可以了(建议直接使用SQLite，反正就你自己用)。&#34;&gt;http://IP:3000，填写服务器信息就可以了(建议直接使用SQLite，反正就你自己用)。&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;部署应用&#34;&gt;部署应用&lt;/h2&gt;

&lt;h3 id=&#34;端口问题&#34;&gt;端口问题&lt;/h3&gt;

&lt;p&gt;端口占用问题，可以通过启动命令指定端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gogs web -port 3001
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开机启动&#34;&gt;开机启动&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;采用Systemd以守护进程定义service运行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.在&lt;code&gt;/etc/systemd/system/gogs.service&lt;/code&gt;新建文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Unit]
Description=Gogs (Go Git Service)
After=syslog.target
After=network.target
#After=mysqld.service
#After=postgresql.service
#After=memcached.service
#After=redis.service

[Service]
# Modify these two values and uncomment them if you have
# repos with lots of files and get an HTTP error 500 because
# of that
###
#LimitMEMLOCK=infinity
#LimitNOFILE=65535
Type=simple
User=git
Group=git
WorkingDirectory=/home/git/gogs
ExecStart=/home/git/gogs/gogs web
Restart=always
Environment=USER=git HOME=/home/git

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.更新 User、Group、WorkingDirectory、ExecStart 和 Environment 为相对应的值。其中 WorkingDirectory 为您的 Gogs 实际安装路径根目录。&lt;/p&gt;

&lt;p&gt;3.[可选] 如果您 Gogs 安装示例使用 MySQL/MariaDB、PostgreSQL、Redis 或 memcached，请去掉相应 After 属性的注释。&lt;/p&gt;

&lt;p&gt;4.然后通过 &lt;code&gt;sudo systemctl enable gogs&lt;/code&gt; 命令激活，最后执行 &lt;code&gt;sudo systemd start gogs&lt;/code&gt;，就可以做到开机启动了。&lt;/p&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gogs.io/docs/installation/install_from_binary&#34;&gt;Gogs二进制安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>树莓派搭建ownCloud</title>
      <link>http://wixb50.github.io/2016/05/18/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAowncloud/</link>
      <pubDate>Wed, 18 May 2016 14:25:17 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/05/18/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAowncloud/</guid>
      <description>

&lt;h2 id=&#34;简介:d7d9936e2453b500c8afe809383d64a8&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;我们将要搭建自己的云系统平台，更精确点是一个云存储系统，我们将使用开源的软件ownCloud搭建私有云，这个平台已经适用于大多数主流平台，android、IOS、mac、linux、windows都是可以的。&lt;/p&gt;

&lt;p&gt;首先介绍一下ownCloud： 简单来说就是一个基于PHP的自建网盘。基本上是私人使用，没有用户注册功能，但是有用户添加功能，你可以无限制地添加用户，OwnCloud还提供了不少的免费应用，这些应用可以让你更好观看视频、倾听音乐等。&lt;/p&gt;

&lt;h2 id=&#34;安装步骤:d7d9936e2453b500c8afe809383d64a8&#34;&gt;安装步骤&lt;/h2&gt;

&lt;h3 id=&#34;安装lamp套件:d7d9936e2453b500c8afe809383d64a8&#34;&gt;安装LAMP套件&lt;/h3&gt;

&lt;p&gt;1.安装apache2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install apache2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.安装mysql&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install mysql-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.安装php和依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install php5 php5-mysql php5-gd php5-curl #其中可能漏掉了，有错误提示的时候装上即可
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.从  &lt;a href=&#34;https://owncloud.org/install/&#34;&gt;https://owncloud.org/install/&lt;/a&gt; 下载最新的ownCloud Server&lt;/p&gt;

&lt;p&gt;5.web服务器的根目录为&lt;code&gt;/var/www/html&lt;/code&gt;将文件解压到本目录即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /var/www/html  #（网页目录）
tar -xzvf owncloud-9.0.1.tar.bz2 -C  /var/www/html   #(解压至web目录)
cd /var/www/html/owncloud         #（进入owncloud web目录）
mkdir data          #(建立数据库目录)
cd data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.OwnCloud在安装的过程中需要对一些目录有写的权限,为此，web服务器用户（www-data对于基于Debian的系统）必须要拥有apps、data、config目录的权限。运行以下命令完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#owncloud 目录下
sudo chown -R www-data:www-data data 
sudo chown -R www-data:www-data config 
sudo chown -R www-data:www-data apps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.打开浏览器，输入 &lt;a href=&#34;http://IP/owncloud&#34;&gt;http://IP/owncloud&lt;/a&gt; ,进入设置界面设计，即可访问&lt;/p&gt;

&lt;h2 id=&#34;参考资料:d7d9936e2453b500c8afe809383d64a8&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.voidcn.com/blog/u010873775/article/p-5812004.html&#34;&gt;使用owncloud云服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>npm命令个人笔记</title>
      <link>http://wixb50.github.io/2016/05/14/npm%E5%91%BD%E4%BB%A4%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 14 May 2016 12:51:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/05/14/npm%E5%91%BD%E4%BB%A4%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h1 id=&#34;修改npm源为淘宝npm源的三种方法&#34;&gt;修改npm源为淘宝npm源的三种方法&lt;/h1&gt;

&lt;p&gt;镜像地址：&lt;a href=&#34;https://npm.taobao.org/&#34;&gt;淘宝 NPM 镜像&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;通过config命令&#34;&gt;通过config命令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org 
npm info underscore （如果上面配置正确这个命令会有字符串response）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;命令行指定&#34;&gt;命令行指定&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;npm --registry https://registry.npm.taobao.org info underscore 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编辑-npmrc-加入下面内容&#34;&gt;编辑 ~/.npmrc 加入下面内容&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;registry = https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tutorial&#34;&gt;tutorial&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://javascript.ruanyifeng.com/nodejs/npm.html&#34;&gt;npm模块管理器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ssh_config来管理ssh会话</title>
      <link>http://wixb50.github.io/2016/04/28/ssh_config%E6%9D%A5%E7%AE%A1%E7%90%86ssh%E4%BC%9A%E8%AF%9D/</link>
      <pubDate>Thu, 28 Apr 2016 18:15:30 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/04/28/ssh_config%E6%9D%A5%E7%AE%A1%E7%90%86ssh%E4%BC%9A%E8%AF%9D/</guid>
      <description>

&lt;h2 id=&#34;简介:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;通常利用 ssh 连接远程服务器，一般都要输入以下类型命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh user@hostname -p port
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果有多个服务器的话，每次都需要重新输入，还需要专门记忆，个人比较懒，不想记这么多，也不想为了登录一个server，打重复代码太多。&lt;/p&gt;

&lt;p&gt;一般，有一种解决方案是，采用第三方的manager工具，比如：putty、PAC manager，但是对于喜欢在终端玩耍的孩纸就不喜欢这个了。&lt;/p&gt;

&lt;h2 id=&#34;ssh-config方案:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;ssh_config方案&lt;/h2&gt;

&lt;p&gt;还好，ssh提供一种优雅灵活的方案，就是利用ssh的用户配置文件config管理ssh会话。ssh的用户配置文件放在用户&lt;code&gt;~/.ssh/config&lt;/code&gt;目录中，不存在则新建一个。配置语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host 别名
    HostName  主机名
    User      用户名
    Port      端口，默认22
    IdentityFile 密钥文件的路径，默认当前目录的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这些配置，就可以这样用ssh 登录服务器了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh 别名
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ps:0984e7ebd3dce43c74ff94df48f1ae75&#34;&gt;Ps&lt;/h2&gt;

&lt;p&gt;如果需要实现无密码登录主机的，请在自行google配置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>实用的20个正则表达式</title>
      <link>http://wixb50.github.io/2016/04/23/%E5%AE%9E%E7%94%A8%E7%9A%8420%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 23 Apr 2016 11:35:17 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/04/23/%E5%AE%9E%E7%94%A8%E7%9A%8420%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>

&lt;p&gt;正则表达式，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。&lt;/p&gt;

&lt;p&gt;正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reg = /^(\\d{1,4})(-|\\/)(\\d{1,2})\\2(\\d{1,2})$/;
var r = fieldValue.match(reg);
if(r==null)alert(&#39;Date format error!&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是整理的，在开发中经常使用到的20个正则表达式。&lt;/p&gt;

&lt;h4 id=&#34;1-校验密码强度:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;1 . 校验密码强度&lt;/h4&gt;

&lt;p&gt;密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-校验中文:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;2. 校验中文&lt;/h4&gt;

&lt;p&gt;字符串仅能是中文。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^[\\u4e00-\\u9fa5]{0,}$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-由数字-26个英文字母或下划线组成的字符串:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;3. 由数字、26个英文字母或下划线组成的字符串&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;^\\w+$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-校验e-mail-地址:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;4. 校验E-Mail 地址&lt;/h4&gt;

&lt;p&gt;同密码一样，下面是E-mail地址合规性的正则检查语句。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-校验身份证号码:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;5. 校验身份证号码&lt;/h4&gt;

&lt;p&gt;下面是身份证号码的正则校验。15 或 18位。&lt;br /&gt;
15位：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;18位：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;6-校验日期:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;6. 校验日期&lt;/h4&gt;

&lt;p&gt;“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;7-校验金额:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;7. 校验金额&lt;/h4&gt;

&lt;p&gt;金额校验，精确到2位小数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^[0-9]+(.[0-9]{2})?$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;8-校验手机号:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;8. 校验手机号&lt;/h4&gt;

&lt;p&gt;下面是国内 13、15、18开头的手机号正则表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;9-判断ie的版本:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;9. 判断IE的版本&lt;/h4&gt;

&lt;p&gt;IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;10-校验ip-v4地址:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;10. 校验IP-v4地址&lt;/h4&gt;

&lt;p&gt;IP4 正则语句。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;11-校验ip-v6地址:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;11. 校验IP-v6地址&lt;/h4&gt;

&lt;p&gt;IP6 正则语句。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;12-检查url的前缀:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;12. 检查URL的前缀&lt;/h4&gt;

&lt;p&gt;应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!s.match(/^[a-zA-Z]+:\\/\\//)){
s = &#39;http://&#39; + s;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;13-提取url链接:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;13. 提取URL链接&lt;/h4&gt;

&lt;p&gt;下面的这个表达式可以筛选出一段文本中的URL。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;amp;=]*)?
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;14-文件路径及扩展名校验:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;14. 文件路径及扩展名校验&lt;/h4&gt;

&lt;p&gt;验证文件路径和扩展名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&amp;quot;&amp;lt;&amp;gt;|]+\\.txt(l)?$
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;15-提取color-hex-codes:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;15. 提取Color Hex Codes&lt;/h4&gt;

&lt;p&gt;有时需要抽取网页中的颜色代码，可以使用下面的表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\\#([a-fA-F]|[0-9]){3,6}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;16-提取网页图片:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;16. 提取网页图片&lt;/h4&gt;

&lt;p&gt;假若你想提取网页中所有图片信息，可以利用下面的表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\\&amp;lt; *[img][^\\&amp;gt;]*[src] *= *[\\&amp;quot;\\&#39;]{0,1}([^\\&amp;quot;\\&#39;\\ &amp;gt;]*)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;17-提取页面超链接:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;17. 提取页面超链接&lt;/h4&gt;

&lt;p&gt;提取html中的超链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(&amp;lt;a\\s*(?!.*\\brel=)[^&amp;gt;]*)(href=&amp;quot;https?://)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&amp;quot;]+)&amp;quot;((?!.*\\brel=)[^&amp;gt;]*)(?:[^&amp;gt;]*)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;18-精炼css:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;18. 精炼CSS&lt;/h4&gt;

&lt;p&gt;通过下面的表达式，可以搜索相同属性值的CSS，从而达到精炼代码的目的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;19-抽取注释:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;19. 抽取注释&lt;/h4&gt;

&lt;p&gt;如果你需要移除HMTL中的注释，可以使用如下的表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--(.*?)--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;20-匹配html标签:70935e7c5f4b3df59cdd661ce63710f7&#34;&gt;20. 匹配HTML标签&lt;/h4&gt;

&lt;p&gt;通过下面的表达式可以匹配出HTML中的标签。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;/?\\w+((\\s+\\w+(\\s*=\\s*(?:&amp;quot;.*?&amp;quot;|&#39;.*?&#39;|[\\^&#39;&amp;quot;&amp;gt;\\s]+))?)+\\s*|\\s*)/?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Docker集群系列之－Kubernetes对象文件定义</title>
      <link>http://wixb50.github.io/2016/03/13/docker%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97%E4%B9%8Bkubernetes%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Sun, 13 Mar 2016 15:10:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/03/13/docker%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97%E4%B9%8Bkubernetes%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89/</guid>
      <description>

&lt;h2 id=&#34;说明:face623dedab27120a5b251ee433661e&#34;&gt;说明&lt;/h2&gt;

&lt;p&gt;主要对kubernetes用户需要定义的Pod,RC和Service的配置文件进行详细说明。&lt;/p&gt;

&lt;h2 id=&#34;pod定义文件详解:face623dedab27120a5b251ee433661e&#34;&gt;Pod定义文件详解&lt;/h2&gt;

&lt;p&gt;Pod定义文件模板(yaml格式)如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1      # required
kind: Pod           # required
metadata:           # required
  name: string      # required
  namespace: string      # required
  labels:
    - name: string
  annotations:
    - name: string
spec:       # required
  containers:       # required
    - name: string      # required
      image: string     # required
      imagePullPolicy: [Always | Never | IfNotPresent]
      command: [string]
      workingDir: string
      volumeMounts:
        - name: string
          mountPath: string
          readOnly: boolean
      ports:
        - name: string
          containerPort: int
          hostPort: int
          protocol: string
      env:
        - name: string
          value: string
      resources:
        limits:
         cpu: string
         memory: string
  volumes:
    - name: string
      # Either emptyDir for an empty directory
      emptyDir: {}
      # Or hostPath for a pre-existing directory on the host
      hostPath:
        path: string
  restartPolicy: [Always | Never | OnFailure]
  dnsPlicy: [Default | ClusterFirst]        # required
  nodeSelector: object
  imagePullSercret: object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对Pod各属性详细说明表如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;属 性 名 称&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;取 值 类 型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;是 否 必 选&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;取 值 说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;version&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;v1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;kind&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Pod&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;metadata&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;元数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;hellip;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;hellip;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;hellip;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;rc定义文件详解:face623dedab27120a5b251ee433661e&#34;&gt;RC定义文件详解&lt;/h2&gt;

&lt;p&gt;RC(ReplicationController)定义文件模板(yaml格式)如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1      # required
kind: ReplicationController           # required
metadata:           # required
  name: string      # required
  namespace: string      # required
  labels:
    - name: string
  annotations:
    - name: string
spec:       # required
  replicas: number      # required
  selector: []      # required
  template: object      # required
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;service定义文件详解:face623dedab27120a5b251ee433661e&#34;&gt;Service定义文件详解&lt;/h2&gt;

&lt;p&gt;Service定义文件模板(yaml格式)如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1      # required
kind: Service           # required
metadata:           # required
  name: string      # required
  namespace: string      # required
  labels:
    - name: string
  annotations:
    - name: string
spec:       # required
  selector: []      # required
  type: string      #required
  clusterIP: string
  sessionAffinity: string
  ports:
    - name: string
      port: int
      targetPort: int
      protocol: string
  status:
    loadBalancer:
      ingress:
        ip: string
        hostname: string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对Service各属性详细说明表如下：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;属 性 名 称&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;取 值 类 型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;是 否 必 选&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;取 值 说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;version&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;v1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;kind&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Pod&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;metadata&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;元数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;metadata.name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Service名称，符合RFC1035规范&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;metadata.namespace&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;命名空间，不指定时系统使用名为&amp;raquo;default&amp;raquo;的命名空间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;metadata.labels[]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;自定义标签属性列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;metadata.annotation[]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;自定义注解属性列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;详细描述&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.selector[]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Label Selector配置，将选择具有指定label标签的Pod作为管理范围&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.type&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Required&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Service类型，指定Service访问方式，默认为ClusterIP。&lt;br&gt;ClusterIP: 虚拟的服务IP地址，该地址用户kubernetes集群内部Pod访问，在Node上kube-proxy通过设置的iptables规则进行转发;&lt;br&gt;NodePort: 使用宿主机的端口，使能够访问各Node的外部客户端通过Node的IP地址和端口号就能访问服务;&lt;br&gt;LoadBalancer: 使用外接负载均衡器完成到服务的负载分发，需要在spec.status.loadBalancer字段指定外部负载均衡器的IP地址，并同时定义nodePort和clusterIP.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.clusterIP&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;虚拟服务IP地址，当type=ClusterIP时，如果不指定，则系统自动分配;当type=LoadBalancer时，则需要指定。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.sessionAffinity&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;是否支持Session，可选值为ClientIP，默认为空。&lt;br&gt;ClientIP: 表示同一个客户端(根据客户端的IP地址决定)的访问请求都转发到同一个后端Pod。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.ports[]&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;list&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Service需要暴露的端口号列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.ports[].name&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;String&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;端口名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.ports[].port&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;服务监听的端口号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.ports[].targetPort&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;需要转发到后端Pod的端口号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;spec.ports[].protocol&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;int&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;端口协议，支持TCP和UDP，默认TCP&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;status&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;当spec.type=LoadBalancer时，设置外部负载均衡器的地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;status.loadBalancer&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;外部负载均衡器&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;status.loadBalancer.ingress&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;object&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;外部负载均衡器&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;status.loadBalancer.ingress.ip&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;外部负载均衡器的IP地址&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;status.loadBalancer.ingress.hostname&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;string&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;外部负载均衡器的主机名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;附录:face623dedab27120a5b251ee433661e&#34;&gt;附录&lt;/h2&gt;

&lt;p&gt;根据yaml创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create -f &amp;lt;filename.yaml&amp;gt; [--validate[=true]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据yaml删除：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl delete -f &amp;lt;filename.yaml&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>nosql介绍</title>
      <link>http://wixb50.github.io/2016/03/08/nosql%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 08 Mar 2016 10:32:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/03/08/nosql%E4%BB%8B%E7%BB%8D/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Github Star</title>
      <link>http://wixb50.github.io/2016/02/27/github-star/</link>
      <pubDate>Sat, 27 Feb 2016 09:26:17 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/02/27/github-star/</guid>
      <description>

&lt;h2 id=&#34;docker:d685a63346009b103c6a9f19e03bdb28&#34;&gt;Docker&lt;/h2&gt;

&lt;h3 id=&#34;应用:d685a63346009b103c6a9f19e03bdb28&#34;&gt;应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/huichen/zerg&#34;&gt;基于docker的分布式爬虫服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;markdown:d685a63346009b103c6a9f19e03bdb28&#34;&gt;MarkDown&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/geekcompany/ResumeSample&#34;&gt;程序员简历MD模板&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tex:d685a63346009b103c6a9f19e03bdb28&#34;&gt;Tex&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/billryan/resume/tree/zh_CN&#34;&gt;一个简洁优雅的 XeLaTeX 简历模板&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;frontend:d685a63346009b103c6a9f19e03bdb28&#34;&gt;Frontend&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/AutumnsWind/Front-end-tutorial&#34;&gt;最全的资源教程-前端涉及的所有知识体系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>文章收藏</title>
      <link>http://wixb50.github.io/2016/02/27/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/</link>
      <pubDate>Sat, 27 Feb 2016 09:25:17 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/02/27/%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/</guid>
      <description>

&lt;h2 id=&#34;opensource&#34;&gt;OpenSource&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5MzM3NjM4MA==&amp;amp;mid=405458525&amp;amp;idx=1&amp;amp;sn=55df62ed6bd01823806a0f1823f3d09c&amp;amp;scene=1&amp;amp;srcid=02264HbqiU0NKglMR5FpYrxr&amp;amp;key=710a5d99946419d952b51286bb476ae852980381752236f35f6efed2d81774806f1a7c345fa76ff83cf2e78cf079c5ea&amp;amp;ascene=0&#34;&gt;科技公司钟爱的50款开源工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://toutiao.com/a6249769056532447489/&#34;&gt;开源软件TOP10-上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.luoyuanhang.com/2016/03/27/%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB/&#34;&gt;技术干货分享&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python&#34;&gt;Python&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://codingpy.com/article/the-idiomatic-way-to-merge-dicts-in-python/?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&#34;&gt;怎样合并字典最符合Python语言习惯&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.imooc.com/article/1149&#34;&gt;八个最实用的Java开发工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/1459&#34;&gt;Java开发常用的在线工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.smoker.cc/translation/20160511.html&#34;&gt;Better Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;golang&#34;&gt;Golang&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://xhrwang.me/2014/12/22/golang-fundamentals-1-types-variables-constants.html&#34;&gt;Golang语言基础&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;react&#34;&gt;React&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dingyiming/learn-Js-react/issues/1&#34;&gt;【资料汇总】React (中文)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;javascript&#34;&gt;JavaScript&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://web.jobbole.com/85265/&#34;&gt;JavaScript 开发最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;web&#34;&gt;Web&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.brucefeng.info/post/brower-server-msg&#34;&gt;浏览器与服务器的消息通信&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dou-bi.com/dbwz-3/&#34;&gt;教你申请.tk/.ml/.cf/.gq/.ga等免费域名&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sql&#34;&gt;SQL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000004443840#articleHeader0&#34;&gt;关系型数据库树形结构的设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://sunheran.com/2015/01/27/database-design/&#34;&gt;数据库设计那些事&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://qinghua.github.io/kubernetes-in-mesos-1/&#34;&gt;如果有10000台机器，你想怎么玩?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;archatecture&#34;&gt;Archatecture&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://toutiao.com/m6140376053/&#34;&gt;微服务实战：从发布到架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;latex&#34;&gt;LaTex&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/jingwhale/p/4250296.html&#34;&gt;LaTex排版全解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lai18.com/content/1987690.html&#34;&gt;PDFLaTex-XeLatex-PDFTex-XeTex等区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ubuntu&#34;&gt;Ubuntu&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jianshu.com/p/4adbfd83b29f&#34;&gt;Linux平台常用软件总结(Ubuntu版)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;other&#34;&gt;Other&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.imooc.com/article/4071&#34;&gt;应该掌握的10个搜索技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>linux 路由表设置 之 route 指令</title>
      <link>http://wixb50.github.io/2016/02/26/linux-%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%AE%BE%E7%BD%AE-%E4%B9%8B-route-%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Fri, 26 Feb 2016 22:15:30 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/02/26/linux-%E8%B7%AF%E7%94%B1%E8%A1%A8%E8%AE%BE%E7%BD%AE-%E4%B9%8B-route-%E6%8C%87%E4%BB%A4/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;路由表（routing table）是一个存储在路由器或者联网计算机中的电子表格或类数据库。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。&lt;/p&gt;

&lt;p&gt;在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了;可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。&lt;/p&gt;

&lt;h2 id=&#34;使用实例&#34;&gt;使用实例&lt;/h2&gt;

&lt;p&gt;route 或者 route -n&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# route 
Destination     Gateway         Genmask Flags Metric Ref    Use Iface  
192.168.0.0     *               255.255.255.0   U     0      0        0 eth0  
169.254.0.0     *               255.255.0.0     U     0      0        0 eth0  
default         192.168.0.1     0.0.0.0         UG    0      0        0 eth0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;route 命令的输出项说明：&lt;/p&gt;

&lt;p&gt;Gateway 网关地址，”*” 表示目标是本主机所属的网络，不需要路由&lt;br /&gt;
Genmask 网络掩码&lt;br /&gt;
Flags   标记。一些可能的标记如下：&lt;br /&gt;
　U Up表示此路由当前为启动状态&lt;br /&gt;
　H Host，表示此网关为一主机&lt;br /&gt;
　G Gateway，表示此网关为一路由器&lt;br /&gt;
　R Reinstate Route，使用动态路由重新初始化的路由&lt;br /&gt;
　D Dynamically,此路由是动态性地写入&lt;br /&gt;
　M Modified，此路由是由路由守护程序或导向器动态修改&lt;br /&gt;
　! 表示此路由当前为关闭状态&lt;br /&gt;
Metric  路由距离，到达指定网络所需的中转数（linux 内核中没有使用）&lt;br /&gt;
Ref 路由项引用次数（linux 内核中没有使用）&lt;br /&gt;
Use 此路由项被路由软件查找的次数&lt;br /&gt;
Iface   该路由表项对应的输出接口&lt;br /&gt;
备注：&lt;br /&gt;
route -n (-n 表示不解析名字,列出速度会比route 快)&lt;/p&gt;

&lt;h2 id=&#34;3-种路由类型&#34;&gt;3 种路由类型&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;主机路由&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主机路由是路由选择表中指向单个IP地址或主机名的路由记录。主机路由的Flags字段为H。例如，在下面的示例中，本地主机通过IP地址192.168.1.1的路由器到达IP地址为10.0.0.10的主机。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Destination    Gateway       Genmask Flags     Metric    Ref    Use    Iface
-----------    -------     -------            -----     ------    ---    ---    -----
10.0.0.10     192.168.1.1    255.255.255.255   UH       0    0      0    eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;网络路由&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;网络路由是代表主机可以到达的网络。网络路由的Flags字段为N。例如，在下面的示例中，本地主机将发送到网络192.19.12.0的数据包转发到IP地址为192.168.1.1的路由器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Destination    Gateway       Genmask Flags    Metric    Ref     Use    Iface
-----------    -------     -------         -----    -----   ---    ---    -----
192.19.12.0     192.168.1.1    255.255.255.0      UN      0       0     0    eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认路由&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当主机不能在路由表中查找到目标主机的IP地址或网络路由时，数据包就被发送到默认路由（默认网关）上。默认路由的Flags字段为G。例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Destination    Gateway       Genmask Flags     Metric    Ref    Use    Iface
-----------    -------     ------- -----      ------    ---    ---    -----
default       192.168.1.1     0.0.0.0    UG       0        0     0    eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置静态路由&#34;&gt;配置静态路由&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;route 命令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置和查看路由表都可以用 route 命令，设置内核路由表的命令格式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用&amp;raquo;add&amp;raquo;或者&amp;raquo;del&amp;raquo;参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。&lt;/p&gt;

&lt;p&gt;其中：&lt;br /&gt;
　-c 显示更多信息&lt;br /&gt;
　-n 不解析名字&lt;br /&gt;
　-v 显示详细的处理信息&lt;br /&gt;
　-F 显示发送信息&lt;br /&gt;
　-C 显示路由缓存&lt;br /&gt;
　-f 清除所有网关入口的路由表。&lt;/p&gt;

&lt;h2 id=&#34;p-与-add-命令一起使用时使路由具有永久性&#34;&gt;　-p 与 add 命令一起使用时使路由具有永久性。&lt;/h2&gt;

&lt;p&gt;　add:添加一条新路由。&lt;br /&gt;
　del:删除一条路由。&lt;br /&gt;
　-net:目标地址是一个网络。&lt;br /&gt;
　-host:目标地址是一个主机。&lt;br /&gt;
　netmask:当添加一个网络路由时，需要使用网络掩码。&lt;br /&gt;
　gw:路由数据包通过网关。注意，你指定的网关必须能够达到。&lt;br /&gt;
　metric：设置路由跳数。&lt;br /&gt;
　Command 指定您想运行的命令 (Add/Change/Delete/Print)。&lt;br /&gt;
　Destination 指定该路由的网络目标。&lt;br /&gt;
　mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。&lt;br /&gt;
　Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。&lt;br /&gt;
　metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。&lt;br /&gt;
　if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;route 命令使用举例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;添加到主机的路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# route add -host 192.168.1.2 dev eth0 
# route add -host 10.20.30.148 gw 10.20.30.40     #添加到10.20.30.148的网管
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加到网络的路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# route add -net 10.20.30.0 netmask 255.255.255.0 eth0   #添加10.20.30.40的网络
# route add -net 10.20.30.0 netmask 255.255.255.0 gw 10.20.30.41 #添加10.20.30.48的网络
# route add -net 192.168.1.0/24 eth1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加默认路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# route add default gw 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除路由&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# route del -host 192.168.1.2 dev eth0:0
# route del -host 10.20.30.148 gw 10.20.30.40
# route del -net 10.20.30.40 netmask 255.255.255.248 eth0
# route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41
# route del -net 192.168.1.0/24 eth1
# route del default gw 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;end&#34;&gt;End&lt;/h2&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.2cto.com/net/201503/386381.html&#34;&gt;Linux route命令详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/vevenlcf/article/details/48026965&#34;&gt;route 指令详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>pip常用命令</title>
      <link>http://wixb50.github.io/2016/02/21/pip%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 21 Feb 2016 13:32:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2016/02/21/pip%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>

&lt;h3 id=&#34;列出已安装的包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;列出已安装的包&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;pip freeze&lt;/code&gt; or &lt;code&gt;pip list&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;导出requirements-txt:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;导出requirements.txt&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;pip freeze &amp;gt; &amp;lt;目录&amp;gt;/requirements.txt&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;安装包&lt;/h2&gt;

&lt;h3 id=&#34;在线安装:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;在线安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip install &amp;lt;包名&amp;gt; 或 pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过使用== &amp;gt;= &amp;lt;= &amp;gt; &amp;lt;来指定版本，不写则安装最新版&lt;/p&gt;

&lt;p&gt;requirements.txt内容格式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Django==1.5.4
MySQL-Connector-Python==2.0.1
MySQL-python==1.2.3
PIL==1.1.7
South==1.0.2
django-grappelli==2.6.3
django-pagination==1.0.7
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装本地安装包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;安装本地安装包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip install &amp;lt;目录&amp;gt;/&amp;lt;文件名&amp;gt; 或 pip install --use-wheel --no-index --find-links=wheelhouse/ &amp;lt;包名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;&amp;lt;包名&amp;gt;前有空格&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;可简写为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --no-index -f=&amp;lt;目录&amp;gt;/ &amp;lt;包名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;卸载包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;卸载包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip uninstall &amp;lt;包名&amp;gt; 或 pip uninstall -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;升级包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;升级包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip install -U &amp;lt;包名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;升级pip:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;升级pip&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip install -U pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示包所在的目录:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;显示包所在的目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip show -f &amp;lt;包名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;搜索包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;搜索包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip search &amp;lt;搜索关键字&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查询可升级的包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;查询可升级的包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip list -o
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;下载包而不安装:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;下载包而不安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip install &amp;lt;包名&amp;gt; -d &amp;lt;目录&amp;gt; 或 pip install -d &amp;lt;目录&amp;gt; -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;打包:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;打包&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pip wheel &amp;lt;包名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考资料:d15648cfed87d3d030e8555bf3cc01a5&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://pip.pypa.io/en/latest/&#34;&gt;pip document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
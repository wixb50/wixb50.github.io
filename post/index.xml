<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Wixb blog</title>
    <link>http://wixb50.github.io/post/</link>
    <description>Recent content in Posts on Wixb blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wixb50@gmail.com (Wixb)</managingEditor>
    <webMaster>wixb50@gmail.com (Wixb)</webMaster>
    <copyright>(c) 2015 wixb.All rights reserved.</copyright>
    <lastBuildDate>Wed, 30 Dec 2015 19:10:38 +0800</lastBuildDate>
    <atom:link href="http://wixb50.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Docker集群系列之－ESXi5.5上搭建基于CoreOS的kubernetes集群</title>
      <link>http://wixb50.github.io/2015/12/30/docker%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97%E4%B9%8Besxi5.5%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ecoreos%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Wed, 30 Dec 2015 19:10:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/30/docker%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97%E4%B9%8Besxi5.5%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ecoreos%E7%9A%84kubernetes%E9%9B%86%E7%BE%A4/</guid>
      <description>

&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#vmware-coreos-multi-nodes-kubernetes&#34;&gt;VMware-coreos-multi-nodes-Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#prerequisites&#34;&gt;Prerequisites&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#coreos-on-vmware&#34;&gt;CoreOS on VMware&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cloud-config-for-master-node&#34;&gt;Cloud-Config for master node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cloud-config-for-minion-node&#34;&gt;Cloud-Config for minion node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#start-the-cluster&#34;&gt;Start the cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#check&#34;&gt;Check&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#enjoy&#34;&gt;Enjoy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reference&#34;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appendix&#34;&gt;Appendix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h1 id=&#34;vmware-coreos-multi-nodes-kubernetes&#34;&gt;VMware-coreos-multi-nodes-Kubernetes&lt;/h1&gt;

&lt;p&gt;Create a Kubernetes Cluster on VMware ESXi with CoreOS.&lt;/p&gt;

&lt;h1 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;VMware ESXi

&lt;ul&gt;
&lt;li&gt;(optional) a DRS cluster with VCenter for high-availability host.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;DHCP server&lt;/li&gt;
&lt;li&gt;A VMware datastore&lt;/li&gt;
&lt;li&gt;vSphere&lt;/li&gt;
&lt;li&gt;Attention: This requires at least CoreOS version 695.0.0, which includes etcd2.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;coreos-on-vmware&#34;&gt;CoreOS on VMware&lt;/h1&gt;

&lt;p&gt;Based on official documentation : &lt;a href=&#34;https://coreos.com/os/docs/latest/booting-on-vmware.html&#34;&gt;https://coreos.com/os/docs/latest/booting-on-vmware.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Download the OVA, on your local computer :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -LO http://alpha.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Import ova on VMware via the vSphere Client :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;in the menu, click &amp;quot;File &amp;gt; Deploy OVF Template...&amp;quot;
in the wizard, specify the location of the OVA downloaded earlier
name your VM
confirm the settings then click &amp;quot;Finish&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a template via vSphere Client :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;right click on the VM and Template &amp;gt; Convert into template
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can create -at least- 2 servers based on this template, do this task but don&amp;rsquo;t start it yet.&lt;/p&gt;

&lt;h1 id=&#34;cloud-config-for-master-node&#34;&gt;Cloud-Config for master node&lt;/h1&gt;

&lt;p&gt;On the VMware datastore, create a directory and initialize config, example :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p &amp;lt;path to datastore&amp;gt;/cloud-config/master/openstack/latest/ 
cd &amp;lt;path to datastore&amp;gt;/cloud-config/master/openstack/latest/
wget https://raw.githubusercontent.com/kubernetes/kubernetes/master/docs/getting-started-guides/coreos/cloud-configs/master.yaml &amp;amp;&amp;amp; mv master.yaml user_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t forget to add your ssh_key :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim user_data
users:
  - name: &amp;quot;core&amp;quot;
    groups:
      - &amp;quot;sudo&amp;quot;
      - &amp;quot;docker&amp;quot;
    ssh-authorized-keys:   
      - ssh-rsa AAAA...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the master need a static ip address,so you need to add the ip config to &lt;code&gt;user_data&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim user_data
write-files:
  [...]
  - path: /etc/systemd/network/static.network
    permissions: 0644
    content: |
      [Match]
      Name=ens192  # The network card

      [Network]
      Address=192.1.1.150/24
      Gateway=192.1.1.1
      DNS=10.11.248.114
      DNS=8.8.4.4
  [...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you can&amp;rsquo;t get the files on VM,you need download files first,and deploy to your &lt;code&gt;File Server&lt;/code&gt;first.And change the url in the &lt;code&gt;user_data&lt;/code&gt; to your own file position.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Replace `https://github.com/kelseyhightower/setup-network-environment/releases/download/v1.0.0/setup-network-environment` To `&amp;lt;your file url&amp;gt;/setup-network-environment`
Replace `https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-apiserver` To `&amp;lt;your file url&amp;gt;/kube-apiserver`
Replace `https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-controller-manager` To `&amp;lt;your file url&amp;gt;/kube-controller-manager`
Replace `https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-scheduler` To `&amp;lt;your file url&amp;gt;/kube-scheduler`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finaly, replace all &amp;laquo;$private_ipv4&amp;raquo; pattern with the ip of master node. The only way to perform this is to fix a DHCP lease with the MAC address of your master server. This MAC address can be get on vsphere : right click on VM, network adapter. Here, 10.0.0.1 is the master fixed ip address.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i &#39;s|$private_ipv4|10.0.0.1|g&#39; user_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the limitation with coreOS and VMware : &lt;a href=&#34;https://coreos.com/os/docs/latest/booting-on-vmware.html#cloud-config&#34;&gt;https://coreos.com/os/docs/latest/booting-on-vmware.html#cloud-config&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Last step : create an iso :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd &amp;lt;path to datastore&amp;gt;/cloud-config/
mkisofs -R -V config-2 -o config-master.iso master/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;cloud-config-for-minion-node&#34;&gt;Cloud-Config for minion node&lt;/h1&gt;

&lt;p&gt;On the VMware datastore, create a directory and initialize config, example :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p &amp;lt;path to datastore&amp;gt;/cloud-config/minion/openstack/latest/
cd &amp;lt;path to datastore&amp;gt;/cloud-config/minion/openstack/latest/
wget https://raw.githubusercontent.com/kubernetes/kubernetes/master/docs/getting-started-guides/coreos/cloud-configs/node.yaml &amp;amp;&amp;amp; mv node.yaml user_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t forget to add your ssh_key :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vim user_data
users:
  - name: &amp;quot;core&amp;quot;
    groups:
      - &amp;quot;sudo&amp;quot;
      - &amp;quot;docker&amp;quot;
    ssh-authorized-keys:   
      - ssh-rsa AAAA...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you can&amp;rsquo;t get the files on VM,you need download files first,and deploy to your &lt;code&gt;File Server&lt;/code&gt;first.And change the url in the &lt;code&gt;user_data&lt;/code&gt; to your own file position.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Replace `https://github.com/kelseyhightower/setup-network-environment/releases/download/v1.0.0/setup-network-environment` To `&amp;lt;your file url&amp;gt;/setup-network-environment`
Replace `https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-proxy` To `&amp;lt;your file url&amp;gt;/kube-proxy`
Replace `https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kubelet` To `&amp;lt;your file url&amp;gt;/kubelet`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finaly, replace all &amp;laquo;&lt;master-private-ip&gt;&amp;raquo; pattern with the ip of master node. (here 10.0.0.1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i &#39;s|&amp;lt;master-private-ip&amp;gt;|10.0.0.1|g&#39; user_data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last step : create an iso :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd &amp;lt;path to datastore&amp;gt;/cloud-config/
mkisofs -R -V config-2 -o config-minion.iso minion/
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;start-the-cluster&#34;&gt;Start the cluster&lt;/h1&gt;

&lt;p&gt;On firt VM, mount the config-master.iso with VM properties (CD/DVD reader and &amp;laquo;Datastore ISO file&amp;raquo;), browse to &amp;laquo;&lt;path to datastore&gt;/cloud-config/&amp;laquo;. Don&amp;rsquo;t foget to set &amp;laquo;Connect on Start up&amp;raquo;.&lt;/p&gt;

&lt;p&gt;On second, and all other futher nodes  mount the config-minion.iso.&lt;/p&gt;

&lt;p&gt;Start your servers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;&lt;br /&gt;
In order to build the &lt;code&gt;flanneld&lt;/code&gt;,the VMs need to pull the images called &lt;code&gt;quay.io/coreos/flannel&lt;/code&gt;.And if the VMs can&amp;rsquo;t download it,you should get it first,then use the command to load the image.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker load &amp;lt; flanneld-file.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensure all the &lt;code&gt;service&lt;/code&gt; are running.&lt;br /&gt;
&lt;strong&gt;Master:&lt;/strong&gt;&lt;code&gt;docker&lt;/code&gt;、&lt;code&gt;etcd2&lt;/code&gt;、&lt;code&gt;fleet&lt;/code&gt;、&lt;code&gt;flanneld&lt;/code&gt;、&lt;code&gt;setup-network-environment&lt;/code&gt;、&lt;code&gt;kube-apiserver&lt;/code&gt;、&lt;code&gt;kube-controller-manager&lt;/code&gt;、&lt;code&gt;kube-scheduler&lt;/code&gt;.&lt;br /&gt;
&lt;strong&gt;Node:&lt;/strong&gt;&lt;code&gt;docker&lt;/code&gt;、&lt;code&gt;etcd2&lt;/code&gt;、&lt;code&gt;fleet&lt;/code&gt;、&lt;code&gt;flanneld&lt;/code&gt;、&lt;code&gt;setup-network-environment&lt;/code&gt;、&lt;code&gt;kubelet&lt;/code&gt;、&lt;code&gt;kube-proxy&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#you may use these command to start/enable your service:
sudo systemctl daemon-reload
sudo systemctl start &amp;lt;service-name&amp;gt;  #start the service
sudo systemctl enable &amp;lt;service-name&amp;gt;  #Ensure service can boot from the start
sudo systemctl status &amp;lt;service-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;check&#34;&gt;Check&lt;/h1&gt;

&lt;p&gt;Check your cluster heatlh : &lt;a href=&#34;http://10.0.0.1:8080/static/app/#/dashboard/&#34;&gt;http://10.0.0.1:8080/static/app/#/dashboard/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Check each server :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh core@10.0.0.1
journalctl -f
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;enjoy&#34;&gt;Enjoy&lt;/h1&gt;

&lt;p&gt;You may download the kubernetes client tool:&lt;code&gt;kubectl&lt;/code&gt;.Use it manage your cluster.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;get all minion node info.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;get all Pods.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;kubectl get pods
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;get all Replication Controllers.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;kubectl get rc
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;get all Replication Services.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;kubectl get svc
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/xavierbaude/VMware-coreos-multi-nodes-Kubernetes&#34;&gt;VMware-coreos-multi-nodes-Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000002886795&#34;&gt;kubernetes 0.18.1 安装 &amp;amp; 部署 &amp;amp; 初试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://severalnines.com/blog/installing-kubernetes-cluster-minions-centos7-manage-pods-services&#34;&gt;Installing Kubernetes Cluster with 3 minions on CentOS 7 to manage pods and services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dockerpool.com/article/1422538730&#34;&gt;如何在 CoreOS 集群上搭建 Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://qiankunli.github.io/2015/01/29/Kubernetes_installation.html&#34;&gt;在CoreOS集群上搭建Kubernetes&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://dockone.io/article/604&#34;&gt;CoreOS集成Kubernetes核心组件Kubelet&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;appendix&#34;&gt;Appendix&lt;/h1&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The source of &lt;code&gt;master.yaml&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#cloud-config

---
write-files:
  - path: /etc/conf.d/nfs
    permissions: &#39;0644&#39;
    content: |
      OPTS_RPC_MOUNTD=&amp;quot;&amp;quot;
  - path: /opt/bin/wupiao
    permissions: &#39;0755&#39;
    content: |
      #!/bin/bash
      # [w]ait [u]ntil [p]ort [i]s [a]ctually [o]pen
      [ -n &amp;quot;$1&amp;quot; ] &amp;amp;&amp;amp; \
        until curl -o /dev/null -sIf http://${1}; do \
          sleep 1 &amp;amp;&amp;amp; echo .;
        done;
      exit $?

hostname: master
coreos:
  etcd2:
    name: master
    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
    advertise-client-urls: http://$private_ipv4:2379,http://$private_ipv4:4001
    initial-cluster-token: k8s_etcd
    listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001
    initial-advertise-peer-urls: http://$private_ipv4:2380
    initial-cluster: master=http://$private_ipv4:2380
    initial-cluster-state: new
  fleet:
    metadata: &amp;quot;role=master&amp;quot;
  units:
    - name: generate-serviceaccount-key.service
      command: start
      content: |
        [Unit]
        Description=Generate service-account key file

        [Service]
        ExecStartPre=-/usr/bin/mkdir -p /opt/bin
        ExecStart=/bin/openssl genrsa -out /opt/bin/kube-serviceaccount.key 2048 2&amp;gt;/dev/null
        RemainAfterExit=yes
        Type=oneshot
    - name: setup-network-environment.service
      command: start
      content: |
        [Unit]
        Description=Setup Network Environment
        Documentation=https://github.com/kelseyhightower/setup-network-environment
        Requires=network-online.target
        After=network-online.target

        [Service]
        ExecStartPre=-/usr/bin/mkdir -p /opt/bin
        ExecStartPre=/usr/bin/curl -L -o /opt/bin/setup-network-environment -z /opt/bin/setup-network-environment https://github.com/kelseyhightower/setup-network-environment/releases/download/v1.0.0/setup-network-environment
        ExecStartPre=/usr/bin/chmod +x /opt/bin/setup-network-environment
        ExecStart=/opt/bin/setup-network-environment
        RemainAfterExit=yes
        Type=oneshot
    - name: fleet.service
      command: start
    - name: flanneld.service
      command: start
      drop-ins:
        - name: 50-network-config.conf
          content: |
            [Unit]
            Requires=etcd2.service
            [Service]
            ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config &#39;{&amp;quot;Network&amp;quot;:&amp;quot;10.244.0.0/16&amp;quot;, &amp;quot;Backend&amp;quot;: {&amp;quot;Type&amp;quot;: &amp;quot;vxlan&amp;quot;}}&#39;
    - name: docker.service
      command: start
    - name: kube-apiserver.service
      command: start
      content: |
        [Unit]
        Description=Kubernetes API Server
        Documentation=https://github.com/GoogleCloudPlatform/kubernetes
        Requires=setup-network-environment.service etcd2.service generate-serviceaccount-key.service
        After=setup-network-environment.service etcd2.service generate-serviceaccount-key.service

        [Service]
        EnvironmentFile=/etc/network-environment
        ExecStartPre=-/usr/bin/mkdir -p /opt/bin
        ExecStartPre=/usr/bin/curl -L -o /opt/bin/kube-apiserver -z /opt/bin/kube-apiserver https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-apiserver
        ExecStartPre=/usr/bin/chmod +x /opt/bin/kube-apiserver
        ExecStartPre=/opt/bin/wupiao 127.0.0.1:2379/v2/machines
        ExecStart=/opt/bin/kube-apiserver \
        --service-account-key-file=/opt/bin/kube-serviceaccount.key \
        --service-account-lookup=false \
        --admission-control=NamespaceLifecycle,NamespaceAutoProvision,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota \
        --runtime-config=api/v1 \
        --allow-privileged=true \
        --insecure-bind-address=0.0.0.0 \
        --insecure-port=8080 \
        --kubelet-https=true \
        --secure-port=6443 \
        --service-cluster-ip-range=10.100.0.0/16 \
        --etcd-servers=http://127.0.0.1:2379 \
        --public-address-override=${DEFAULT_IPV4} \
        --logtostderr=true
        Restart=always
        RestartSec=10
    - name: kube-controller-manager.service
      command: start
      content: |
        [Unit]
        Description=Kubernetes Controller Manager
        Documentation=https://github.com/GoogleCloudPlatform/kubernetes
        Requires=kube-apiserver.service
        After=kube-apiserver.service

        [Service]
        ExecStartPre=/usr/bin/curl -L -o /opt/bin/kube-controller-manager -z /opt/bin/kube-controller-manager https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-controller-manager
        ExecStartPre=/usr/bin/chmod +x /opt/bin/kube-controller-manager
        ExecStart=/opt/bin/kube-controller-manager \
        --service-account-private-key-file=/opt/bin/kube-serviceaccount.key \
        --master=127.0.0.1:8080 \
        --logtostderr=true
        Restart=always
        RestartSec=10
    - name: kube-scheduler.service
      command: start
      content: |
        [Unit]
        Description=Kubernetes Scheduler
        Documentation=https://github.com/GoogleCloudPlatform/kubernetes
        Requires=kube-apiserver.service
        After=kube-apiserver.service

        [Service]
        ExecStartPre=/usr/bin/curl -L -o /opt/bin/kube-scheduler -z /opt/bin/kube-scheduler https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-scheduler
        ExecStartPre=/usr/bin/chmod +x /opt/bin/kube-scheduler
        ExecStart=/opt/bin/kube-scheduler --master=127.0.0.1:8080
        Restart=always
        RestartSec=10
  update:
    group: alpha
    reboot-strategy: off
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The source of &lt;code&gt;node.yaml&lt;/code&gt;
```
#cloud-config
write-files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;path: /opt/bin/wupiao
permissions: &amp;lsquo;0755&amp;rsquo;
content: |
#!/bin/bash&lt;/p&gt;

&lt;h1 id=&#34;w-ait-u-ntil-p-ort-i-s-a-ctually-o-pen&#34;&gt;[w]ait [u]ntil [p]ort [i]s [a]ctually [o]pen&lt;/h1&gt;

&lt;p&gt;[ -n &amp;laquo;$1&amp;raquo; ] &amp;amp;&amp;amp; [ -n &amp;laquo;$2&amp;raquo; ] &amp;amp;&amp;amp; while ! curl &amp;ndash;output /dev/null \
&amp;ndash;silent &amp;ndash;head &amp;ndash;fail \
http://${1}:${2}; do sleep 1 &amp;amp;&amp;amp; echo -n .; done;
exit $?
coreos:
etcd2:
listen-client-urls: &lt;a href=&#34;http://0.0.0.0:2379,http://0.0.0.0:4001&#34;&gt;http://0.0.0.0:2379,http://0.0.0.0:4001&lt;/a&gt;
advertise-client-urls: &lt;a href=&#34;http://0.0.0.0:2379,http://0.0.0.0:4001&#34;&gt;http://0.0.0.0:2379,http://0.0.0.0:4001&lt;/a&gt;
initial-cluster: master=http://&lt;master-private-ip&gt;:2380
proxy: on
fleet:
metadata: &amp;laquo;role=node&amp;raquo;
units:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: fleet.service
command: start&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: flanneld.service
command: start&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: docker.service
command: start&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: setup-network-environment.service
command: start
content: |
[Unit]
Description=Setup Network Environment
Documentation=&lt;a href=&#34;https://github.com/kelseyhightower/setup-network-environment&#34;&gt;https://github.com/kelseyhightower/setup-network-environment&lt;/a&gt;
Requires=network-online.target
After=network-online.target&lt;/p&gt;

&lt;p&gt;[Service]
ExecStartPre=-/usr/bin/mkdir -p /opt/bin
ExecStartPre=/usr/bin/curl -L -o /opt/bin/setup-network-environment -z /opt/bin/setup-network-environment &lt;a href=&#34;https://github.com/kelseyhightower/setup-network-environment/releases/download/v1.0.0/setup-network-environment&#34;&gt;https://github.com/kelseyhightower/setup-network-environment/releases/download/v1.0.0/setup-network-environment&lt;/a&gt;
ExecStartPre=/usr/bin/chmod +x /opt/bin/setup-network-environment
ExecStart=/opt/bin/setup-network-environment
RemainAfterExit=yes
Type=oneshot&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: kube-proxy.service
command: start
content: |
[Unit]
Description=Kubernetes Proxy
Documentation=&lt;a href=&#34;https://github.com/GoogleCloudPlatform/kubernetes&#34;&gt;https://github.com/GoogleCloudPlatform/kubernetes&lt;/a&gt;
Requires=setup-network-environment.service
After=setup-network-environment.service&lt;/p&gt;

&lt;p&gt;[Service]
ExecStartPre=/usr/bin/curl -L -o /opt/bin/kube-proxy -z /opt/bin/kube-proxy &lt;a href=&#34;https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-proxy&#34;&gt;https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kube-proxy&lt;/a&gt;
ExecStartPre=/usr/bin/chmod +x /opt/bin/kube-proxy&lt;/p&gt;

&lt;h1 id=&#34;wait-for-kubernetes-master-to-be-up-and-ready&#34;&gt;wait for kubernetes master to be up and ready&lt;/h1&gt;

&lt;p&gt;ExecStartPre=/opt/bin/wupiao &lt;master-private-ip&gt; 8080
ExecStart=/opt/bin/kube-proxy \
&amp;ndash;master=&lt;master-private-ip&gt;:8080 \
&amp;ndash;logtostderr=true
Restart=always
RestartSec=10&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;name: kube-kubelet.service
command: start
content: |
[Unit]
Description=Kubernetes Kubelet
Documentation=&lt;a href=&#34;https://github.com/GoogleCloudPlatform/kubernetes&#34;&gt;https://github.com/GoogleCloudPlatform/kubernetes&lt;/a&gt;
Requires=setup-network-environment.service
After=setup-network-environment.service&lt;/p&gt;

&lt;p&gt;[Service]
EnvironmentFile=/etc/network-environment
ExecStartPre=/usr/bin/curl -L -o /opt/bin/kubelet -z /opt/bin/kubelet &lt;a href=&#34;https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kubelet&#34;&gt;https://storage.googleapis.com/kubernetes-release/release/v1.1.2/bin/linux/amd64/kubelet&lt;/a&gt;
ExecStartPre=/usr/bin/chmod +x /opt/bin/kubelet&lt;/p&gt;

&lt;h1 id=&#34;wait-for-kubernetes-master-to-be-up-and-ready-1&#34;&gt;wait for kubernetes master to be up and ready&lt;/h1&gt;

&lt;p&gt;ExecStartPre=/opt/bin/wupiao &lt;master-private-ip&gt; 8080
ExecStart=/opt/bin/kubelet \
&amp;ndash;address=0.0.0.0 \
&amp;ndash;port=10250 \
&amp;ndash;hostname-override=${DEFAULT_IPV4} \
&amp;ndash;api-servers=&lt;master-private-ip&gt;:8080 \
&amp;ndash;allow-privileged=true \
&amp;ndash;logtostderr=true \
&amp;ndash;cadvisor-port=4194 \
&amp;ndash;healthz-bind-address=0.0.0.0 \
&amp;ndash;healthz-port=10248
Restart=always
RestartSec=10
update:
group: alpha
reboot-strategy: off
```&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>aria2 rpc</title>
      <link>http://wixb50.github.io/2015/12/23/aria2-rpc/</link>
      <pubDate>Wed, 23 Dec 2015 16:21:30 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/23/aria2-rpc/</guid>
      <description>

&lt;p&gt;##目录
&amp;lt;!&amp;ndash; MarkdownTOC &amp;ndash;&amp;gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#null-link&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#初步部署-aria2-简易版&#34;&gt;初步部署 Aria2 简易版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#进阶-aria2&#34;&gt;进阶 Aria2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#end&#34;&gt;End&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#参考&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&#34;前言-null-link&#34;&gt;&lt;a href=&#34;chrome://not-a-link&#34;&gt;前言&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://aria2.sourceforge.net/&#34;&gt;Aria2&lt;/a&gt; 是一个轻量级多协议和多源命令行下载实用工具。它支持 HTTP / HTTPS, FTP, SFTP, bt 和 Metalink。通过内置 Aria2 可以操作 json - rpc 和 xml - rpc。对，Aria2 没有 GUI 图形界面，只有粗糙的命令行界面！但这也正是 Aria2 之轻快好省所在。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官方下载链接：&lt;a href=&#34;http://sourceforge.net/projects/aria2/files/stable/&#34;&gt;http://sourceforge.net/projects/aria2/files/stable/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;初步部署-aria2-简易版&#34;&gt;初步部署 Aria2 简易版&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 新建几个有关文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面已经提供了下载链接，根据平台/系统位数（32bit/64bit）下载相应文件即可。（存放路径最好是英文/数字）然后在目录下以新建文本文档的方式新建几个文件，方便之后的使用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Aria2.log（运行日志）&lt;/li&gt;
&lt;li&gt;aria2.session（下载历史）&lt;/li&gt;
&lt;li&gt;aria2.conf（配置文件）&lt;/li&gt;
&lt;li&gt;HideRun.vbs （用来隐藏命令行窗口,仅限windows下）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而后用记事本修改配置文件 aria2.conf，&lt;strong&gt;根据实际情况修改：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir=默认下载目录（例：D:\Inbox）
log=日志文件存放目录（例：D:\Aria2\Aria2.log）
input-file=记录下载历史文件目录（例：D:\Aria2\aria2.session）
save-session=存放下载历史文件目录（例：同上）
save-session-interval=60
force-save=true
log-level=error
  
  
# see --split option
max-concurrent-downloads=5
continue=true
max-overall-download-limit=0
max-overall-upload-limit=50K
max-upload-limit=20
  
# Http/FTP options
connect-timeout=120
lowest-speed-limit=10K
max-connection-per-server=10
max-file-not-found=2
min-split-size=1M
split=5
check-certificate=false
http-no-cache=true
  
# FTP Specific Options
  
# BT/PT Setting
bt-enable-lpd=true
#bt-max-peers=55
follow-torrent=true
enable-dht6=false
bt-seed-unverified
rpc-save-upload-metadata=true
bt-hash-check-seed
bt-remove-unselected-file
bt-request-peer-speed-limit=100K
seed-ratio=0.0
  
  
# Metalink Specific Options
  
# RPC Options
enable-rpc=true
pause=false
rpc-allow-origin-all=true
rpc-listen-all=true
rpc-save-upload-metadata=true
rpc-secure=false
  
# Advanced Options
daemon=true
disable-ipv6=true
enable-mmap=true
file-allocation=falloc
max-download-result=120
#no-file-allocation-limit=32M
force-sequential=true
parameterized-uri=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Windows NOTE :&lt;/strong&gt; 而后修改 HideRun.vbs，将 Aria2c.exe 与配置文件 Aria2.conf 链接，并实现无命令行启动。那么日后打开 Aria2 就双击 HideRun.vbs 这个文件而不是双击 aria2c.exe。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CreateObject(&amp;quot;WScript.Shell&amp;quot;).Run &amp;quot;（程序所在目录 例：D:\Aria2\aria2c.exe） --conf-path=aria2.conf&amp;quot;,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Linux NOTE :&lt;/strong&gt; 可使用配置文件直接运行，转到后台即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --conf-path=aria2.conf &amp;amp;  #其中&amp;amp;(后台运行)是可选项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. Web 前端控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如此这般，Aria2 就配置好了，如果要添加开机自启动将 HideRun.vbs 的快捷方式拖入启动文件夹建立计划任务就 OK 了。那么问题就来了，这么一个看不见摸不着的软件怎么使用？别急，即使没有 GUI，Aria2 也还是有 Web 端控制界面的，目前比较知名的有 &lt;a href=&#34;https://github.com/ziahamza/webui-aria2&#34;&gt;Aria2 Web UI&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/binux/yaaw&#34;&gt;YAAW&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Aria2 Web UI（推荐！）: &lt;a href=&#34;http://ziahamza.github.io/webui-aria2/&#34;&gt;英文原版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;YAAW: &lt;a href=&#34;http://binux.github.io/yaaw/demo/&#34;&gt;英文原版&lt;/a&gt;&lt;br /&gt;
&lt;strong&gt;Tips：其他控制界面/扩展/脚本可能会需要填写 JSON-RPC Path，默认为: &lt;a href=&#34;http://localhost:6800/jsonrpc&#34;&gt;http://localhost:6800/jsonrpc&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简易版的 Aria2 至此就部署完毕，你可以在 Web 控制前段方便地添加下载链接/bt种子了。&lt;/p&gt;

&lt;h2 id=&#34;进阶-aria2&#34;&gt;进阶 Aria2&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. 配置文件 aria2.conf 详解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;更多参数请参考官方说明文档：&lt;a href=&#34;http://aria2.sourceforge.net/manual/en/html/aria2c.html&#34;&gt;http://aria2.sourceforge.net/manual/en/html/aria2c.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;网友翻译的部分内容：  &lt;a href=&#34;http://sydi.org/posts/linux/aria2c-usage-sample-cns.html#fn.1&#34;&gt;http://sydi.org/posts/linux/aria2c-usage-sample-cns.html#fn.1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 结合Docker使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可查看ziahamza大神配置好的：&lt;a href=&#34;https://github.com/ziahamza/webui-aria2&#34;&gt;Aria2 Web UI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 搭配脚本/扩展&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;迅雷离线（需会员账号）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chrome Extension: &lt;a href=&#34;https://chrome.google.com/webstore/detail/thunderlixianassistant/eehlmkfpnagoieibahhcghphdbjcdmen&#34;&gt;ThunderLixianAssistant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;UserScript: &lt;a href=&#34;https://github.com/binux/ThunderLixianExporter&#34;&gt;ThunderLixianExporter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;旋风离线&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UserScript: &lt;a href=&#34;https://greasyfork.org/zh-CN/scripts/354-xuanfengex&#34;&gt;XuanFengEx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;UserScript: &lt;a href=&#34;https://greasyfork.org/zh-CN/scripts/2398-lixianexporter&#34;&gt;LixianExporter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;百度网盘&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chrome Extension: &lt;a href=&#34;https://chrome.google.com/webstore/detail/baiduexporter/mjaenbjdjmgolhoafkohbhhbaiedbkno&#34;&gt;BaiduExporter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Firefox Addons: &lt;a href=&#34;https://github.com/acgotaku/BaiduExporter&#34;&gt;BaiduExporter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;UserScript: &lt;a href=&#34;https://greasyfork.org/scripts/294-baidupandownloadhelper&#34;&gt;BaiduPanDownloadHelper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他脚本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chrome Extension: &lt;a href=&#34;https://chrome.google.com/webstore/detail/%E6%B7%BB%E5%8A%A0%E5%88%B0aria2/nimeojfecmndgolmlmjghjmbpdkhhogl&#34;&gt;添加到 aria2&lt;/a&gt; &lt;a href=&#34;http://git.oschina.net/yky/CDHelper&#34;&gt;Chrome Download Helper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;end&#34;&gt;End&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/aa65535/5e956c4eb4f451ddec29&#34;&gt;https://gist.github.com/aa65535/5e956c4eb4f451ddec29&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>aria2命令</title>
      <link>http://wixb50.github.io/2015/12/23/aria2%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 23 Dec 2015 14:21:30 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/23/aria2%E5%91%BD%E4%BB%A4/</guid>
      <description>

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ria2&#34;&gt;ria2&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#基本使用&#34;&gt;基本使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#基本用法&#34;&gt;基本用法&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#下载一个文件&#34;&gt;下载一个文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#使用两个连接从一个源下载文件&#34;&gt;使用两个连接从一个源下载文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#使用两个连接下载文件：&#34;&gt;使用两个连接下载文件：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#从http或ftp服务器下载：&#34;&gt;从http或ftp服务器下载：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#从任意源进行并行下载：&#34;&gt;从任意源进行并行下载：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#如果仅仅指定本地磁盘上的torrent文件或者metalink，是不需要-z选项的，如：&#34;&gt;如果仅仅指定本地磁盘上的torrent文件或者metalink，是不需要-Z选项的，如：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#从文件中读取目的文件，并行下载&#34;&gt;从文件中读取目的文件，并行下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#退出时保存出错未完成的下载-使用session&#34;&gt;退出时保存出错/未完成的下载, 使用&lt;code&gt;session&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#后续可以使用该文件继续未完成的下载：&#34;&gt;后续可以使用该文件继续未完成的下载：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#metalink相关下载示例&#34;&gt;Metalink相关下载示例&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#从远程metalink下载文件：&#34;&gt;从远程metalink下载文件：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#从远程metalink下载文件但在内存中处理metalink：&#34;&gt;从远程metalink下载文件,但在内存中处理metalink：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过本地metalink下载：&#34;&gt;通过本地metalink下载：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#使用5个server下载&#34;&gt;使用5个server下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过多个本地metalink文件进行下载：&#34;&gt;通过多个本地metalink文件进行下载：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#打印metalink的内容&#34;&gt;打印metalink的内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过序号下载指定文件&#34;&gt;通过序号下载指定文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#指定用户偏好从本地metalink下载文件&#34;&gt;指定用户偏好从本地metalink下载文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bittorrent相关下载&#34;&gt;BitTorrent相关下载&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#通过远程bittorrent文件下载&#34;&gt;通过远程BitTorrent文件下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过远程bittorrent文件下载但在内存中处理&#34;&gt;通过远程BitTorrent文件下载,但在内存中处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过本地torrent文件下载&#34;&gt;通过本地torrent文件下载:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#可以同时处理多个torrent文件&#34;&gt;可以同时处理多个torrent文件:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过bittorrent-magnet-uri下载：&#34;&gt;通过BitTorrent Magnet URI下载：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#自动调整peer节点数量&#34;&gt;自动调整peer节点数量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#开启dht&#34;&gt;开启DHT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#开启ipv6的dht&#34;&gt;开启ipv6的DHT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#增加和删除tracker-uri：&#34;&gt;增加和删除tracker URI：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#加密&#34;&gt;加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#打印torrent文件内容&#34;&gt;打印torrent文件内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过序号选择指定文件下载：&#34;&gt;通过序号选择指定文件下载：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#修改监听端口&#34;&gt;修改监听端口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#指定aria2完成下载后的停止条件&#34;&gt;指定aria2完成下载后的停止条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#设置上传速度&#34;&gt;设置上传速度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#seeding已经下载完成的文件&#34;&gt;Seeding已经下载完成的文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#还可以同时播种多个torrent文件&#34;&gt;还可以同时播种多个torrent文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#通过index指定文件名&#34;&gt;通过index指定文件名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#为进行文件预览进行分片优先下载&#34;&gt;为进行文件预览进行分片优先下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#用代理服务器&#34;&gt;用代理服务器&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#为所有协议httpsftp设定代理服务器&#34;&gt;为所有协议(HTTP(S)/FTP)设定代理服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#设置http代理&#34;&gt;设置http代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#使用需要认证的代理&#34;&gt;使用需要认证的代理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#高级的http特性：&#34;&gt;高级的http特性：&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#导入cookie&#34;&gt;导入cookie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#其他高级特性&#34;&gt;其他高级特性&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#下载速度限制&#34;&gt;下载速度限制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#使用-v修复受损的下载&#34;&gt;使用-V修复受损的下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#当下载速度下于某个特定值时放弃下载&#34;&gt;当下载速度下于某个特定值时放弃下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#uri的参数化支持&#34;&gt;URI的参数化支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#时间戳&#34;&gt;时间戳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#输入文件&#34;&gt;输入文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;p&gt;#aria2
&lt;strong&gt;title:&lt;/strong&gt; aria2 使用说明&lt;br /&gt;
&lt;strong&gt;title:&lt;/strong&gt; aria2,aria2c,wget,linux,下载&lt;br /&gt;
&lt;strong&gt;info:&lt;/strong&gt; &lt;strong&gt;aria2&lt;/strong&gt;是一款轻量型命令行下载工具，它提供了对多协议和多源地址的支持，目前支持的协议包括&lt;strong&gt;HTTP(S), FTP, BitTorrent (DHT, PEX, MSE/PE), and Metalink&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;aria2可以从多个源地址，并使用多种协议进行下载，并尝试将下载带宽利用率最大化。它可以同时从HTTP(S)/FTP 和 BitTorrent下载一份数据，并且将其上传到bt集群中。通过Metalink的分块检查，aria2可以在下载过程中自动的进行数据校验。&lt;/p&gt;

&lt;p&gt;虽然现在有诸如&lt;strong&gt;wget&lt;/strong&gt;和&lt;strong&gt;curl&lt;/strong&gt;等其他类似产品，但aria2具有两个独特的功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;aria2可以从多个源下载文件(HTTP(S)/FTP/BitTorrent)，&lt;/li&gt;
&lt;li&gt;aria2可以并发的进行多个源地址的下载。这样用户将不必等待单个文件的下载完成，而且aria2会尽可能快的下载。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除aria2外，也有一些其他可以进行分片下载的工具，它们往往按照线程数分割文件，并行下载，换言之，它们不会对未完成的部分进行自适应性重新分片，当整个流程工作正常时，这个策略是可以的，但一旦存在一个线程运行非常慢，这样整个进程就需要等待该线程的执行。而aria2可以很好的处理这个情况，它可以将文件分割成1M大小的分片，当某个线程运行特别缓慢时，aria2可以使用更快的线程来替换。总之，根据作者的说法，aria2是非常智能和可靠的。&lt;/p&gt;

&lt;p&gt;和最初的aria工具具有一个GTK+界面不同，aria2只提供了命令行接口，从而使得对资源的要求更小。通常它的物理内存消耗为4M(HTTP/FTP)到9M(BitTorrent),当进行bt下载且速度为2.8M/s时的cpu消耗约为6%。&lt;/p&gt;

&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;

&lt;p&gt;当源地址存在诸如&lt;code&gt;&amp;amp;&lt;/code&gt;或&lt;code&gt;*&lt;/code&gt;等其他shell特殊字符时，请使用单引号或者双引号将uri包含起来。&lt;/p&gt;

&lt;p&gt;在aria2的1.10.0版中，aria2对每台主机默认使用1个连接和20MB的分块大小，所以不论在-s参数中指定任何值，他都对一台主机只会建立一个连接，需要注意的一点是这个限制是针对单个主机的，当指定了多台主机时，它会对每台主机建立一个连接。如果要使用1.9.x版中的行为，则要使用-x16 -k1M。另见man页面的 &lt;code&gt;–max-connection-per-server&lt;/code&gt; 和 &lt;code&gt;–min-split-size&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;_aria2默认会在开始下载前预先分配文件空间以避免可能的文件碎片_，但这会在部分PC上带来50%-90%的cpu消耗。当使用环境为比较新的文件系统，例如ext4，btrfs，xfs或者NTFS时，作者推荐使用&lt;strong&gt;&lt;code&gt;–file-allocation=falloc&lt;/code&gt;&lt;/strong&gt;，这种方式会在瞬间完成大文件（数G）的空间分配并且不会带来额外的性能下降。&lt;/p&gt;

&lt;p&gt;如果你既没有使用cutting-edge文件系统，也没有使用linux，并且很在意系统性能，那么可以使用–file-allocation=none来关闭文件的预分配。&lt;/p&gt;

&lt;p&gt;如果你忘记了这些参数的全名或者含义，把-h放在选项或者词的前面，比如aria2c -hcrypt，这样aria2就会搜索crypt相关的选项并把他的帮助打印出来，如果aria2发现使用了-h，它会在打印出帮助信息后停止运行。&lt;/p&gt;

&lt;h2 id=&#34;基本用法&#34;&gt;基本用法&lt;/h2&gt;

&lt;h3 id=&#34;下载一个文件&#34;&gt;下载一个文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c http://host/image.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在1.10.0版中，aria2对每个host使用一个连接，你可以使用&lt;code&gt;–max-connection-per-server&lt;/code&gt; 或 &lt;code&gt;-x&lt;/code&gt;来修改&lt;/p&gt;

&lt;h3 id=&#34;使用两个连接从一个源下载文件&#34;&gt;使用两个连接从一个源下载文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -x2 http://host/image.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Ctrl+c&lt;/code&gt;可以中止当前的下载，在同样的目录运行同样的命令可以继续原来的下载，你设置可以修改&lt;code&gt;uri&lt;/code&gt;，如果他们指向的是同一个文件的话。&lt;/p&gt;

&lt;h3 id=&#34;使用两个连接下载文件&#34;&gt;使用两个连接下载文件：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -s2 http://host/image.iso http://mirror1/image.iso http://mirror2/image.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：如果命令中uri的数量多于-s的值，如本例所示，aria2将会首先使用前两个uri，将第3个uri作为候补，如果前两个有一个下载失败，就会启用第3个&lt;/p&gt;

&lt;h3 id=&#34;从http或ftp服务器下载&#34;&gt;从http或ftp服务器下载：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c http://host1/file.zip ftp://host2/file.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;从任意源进行并行下载&#34;&gt;从任意源进行并行下载：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -Z http://host/file1 file2.torrent file3.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;如果仅仅指定本地磁盘上的torrent文件或者metalink-是不需要-z选项的-如&#34;&gt;如果仅仅指定本地磁盘上的torrent文件或者metalink，是不需要-Z选项的，如：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c file1.torrent file2.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;从文件中读取目的文件-并行下载&#34;&gt;从文件中读取目的文件，并行下载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -ifiles.txt -j5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：-j参数指定了并发下载的数量，在输入文件中可以包含torrent文件和metelink&lt;br /&gt;
注：输入文件中支持添加参数，详见后续的“输入文件”章节&lt;/p&gt;

&lt;h3 id=&#34;退出时保存出错-未完成的下载-使用-session&#34;&gt;退出时保存出错/未完成的下载, 使用&lt;code&gt;session&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -ifiles.txt --save-session=out.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当ctrl+c或者aria2自己退出时，所有的错误，未完成的下载信息会保存到out.txt中，但通过aria2.addTorrent 和 aria2.addMetalink XML-RPC方式增加的下载不会保存。&lt;/p&gt;

&lt;h3 id=&#34;后续可以使用该文件继续未完成的下载&#34;&gt;后续可以使用该文件继续未完成的下载：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -i out.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;metalink相关下载示例&#34;&gt;Metalink相关下载示例&lt;/h2&gt;

&lt;h3 id=&#34;从远程metalink下载文件&#34;&gt;从远程metalink下载文件：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c http://host/file.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;从远程metalink下载文件-但在内存中处理metalink&#34;&gt;从远程metalink下载文件,但在内存中处理metalink：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --follow-metalink=mem http://host/file.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过本地metalink下载&#34;&gt;通过本地metalink下载：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -t10 --lowest-speed-limit=4000 file.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用5个server下载&#34;&gt;使用5个server下载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -C5 file.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当使用metalink时，-s参数不再起作用，需要使用-C选项&lt;/p&gt;

&lt;h3 id=&#34;通过多个本地metalink文件进行下载&#34;&gt;通过多个本地metalink文件进行下载：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c file1.metalink file2.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;打印metalink的内容&#34;&gt;打印metalink的内容&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -S file.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过序号下载指定文件&#34;&gt;通过序号下载指定文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --select-file=1-4,8 -Mfile.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：可以通过-S选择来打印metalink文件的内容&lt;/p&gt;

&lt;h3 id=&#34;指定用户偏好从本地metalink下载文件&#34;&gt;指定用户偏好从本地metalink下载文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --metalink-location=JP,US --metalink-version=1.1 --metalink-language=en-US file.metali
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bittorrent相关下载&#34;&gt;BitTorrent相关下载&lt;/h2&gt;

&lt;h3 id=&#34;通过远程bittorrent文件下载&#34;&gt;通过远程BitTorrent文件下载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c http://site/file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过远程bittorrent文件下载-但在内存中处理&#34;&gt;通过远程BitTorrent文件下载,但在内存中处理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --follow-torrent=mem http://site/file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过本地torrent文件下载&#34;&gt;通过本地torrent文件下载:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -u40K /path/to/file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：-u, –max-upload-limit用来指定最大上传速度&lt;/p&gt;

&lt;h3 id=&#34;可以同时处理多个torrent文件&#34;&gt;可以同时处理多个torrent文件:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c /path/to/file1.torrent /path/to/file2.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过bittorrent-magnet-uri下载&#34;&gt;通过BitTorrent Magnet URI下载：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c &amp;quot;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&amp;amp;dn=aria2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：需要将magnet的地址用单引号或者双引号引起来，因为里面包含’&amp;amp;&amp;lsquo;字符。当使用magnet时，强烈建议打开dht选项，–enable-dht
将metadata保存成.torrent文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-save-metadata &amp;quot;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&amp;amp;dn=aria2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令会将metadata信息保存在248d0a1cd08284299de78d5c1ed359bb46717d8c.torrent文件中&lt;/p&gt;

&lt;h3 id=&#34;自动调整peer节点数量&#34;&gt;自动调整peer节点数量&lt;/h3&gt;

&lt;p&gt;当所有节点的整体下载速度低于某个值时，aria2可以临时增加节点数量来获取更快的下载速率&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-request-peer-speed-limit=200K file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开启dht&#34;&gt;开启DHT&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --enable-dht http://site/file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：在1.7.2版本后，dht选项是被默认打开的。当aria2只处理http/ftp下载时，不会打开dht选项。当第一个torrent开始下载时，aria2进行DHT功能的初始化，然后一直运行到aria2退出。&lt;/p&gt;

&lt;h3 id=&#34;开启ipv6的dht&#34;&gt;开启ipv6的DHT&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --enable-dht6 --dht-listen-port=6881 --dht-listen-addr6=YOUR_GLOBAL_UNICAST_IPV6_ADDR --enable-async-dns6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：如果aria2在build时没有使用c-ares，则不需要–enable-async-dns6。aria2在ipv4和ipv6的dht中共享一些端口&lt;/p&gt;

&lt;h3 id=&#34;增加和删除tracker-uri&#34;&gt;增加和删除tracker URI：&lt;/h3&gt;

&lt;p&gt;下面这个例子将从file.torrent中移除所有的tracker的uri，然后使用”&lt;a href=&#34;http://tracker1/announce”&#34;&gt;http://tracker1/announce”&lt;/a&gt; 和 “&lt;a href=&#34;http://tracker2/announce”&#34;&gt;http://tracker2/announce”&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-exclude-tracker=&amp;quot;*&amp;quot; --bt-tracker=&amp;quot;http://tracker1/announce,http://tracker2/announce&amp;quot; file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;

&lt;p&gt;在默认情况下，aria2可以接收加密/非加密的连接，并且会首先尝试加密握手，如果失败才会去使用传统的BitTorrent握手
下面这个例子中，aria2将只通过加密的握手接受与建立连接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-require-crypto=true http://site/file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存在两种加密方式，头加密和全连接加密。如果两种都可以被peer提供，aria2将默认使用头加密方式。如果要使用全连接加密，可以使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-min-crypto-level=arc4 http://site/file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;打印torrent文件内容&#34;&gt;打印torrent文件内容&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -S file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过序号选择指定文件下载&#34;&gt;通过序号选择指定文件下载：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --select-file=1-4,8 -Tfile.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：index信息可以通过-S来获得&lt;/p&gt;

&lt;h3 id=&#34;修改监听端口&#34;&gt;修改监听端口&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --listen-port=6881-6883 file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：请确保指定端口可以进行tcp的上行和下行通信&lt;/p&gt;

&lt;h3 id=&#34;指定aria2完成下载后的停止条件&#34;&gt;指定aria2完成下载后的停止条件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --seed-time=120 --seed-ratio=1.0 file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：本例中，aria2会在下载完成后120分钟，或seed ratio达到1.0时退出程序&lt;/p&gt;

&lt;h3 id=&#34;设置上传速度&#34;&gt;设置上传速度&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --max-upload-limit=100K file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;seeding已经下载完成的文件&#34;&gt;Seeding已经下载完成的文件&lt;/h3&gt;

&lt;p&gt;可以使用-V选择来播种下载完成的文件，它会首先对文件进行分片的hash校验&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Seeding already downloaded file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果可以确定下载文件的正确性，可以使用–bt-seed-unverified选项来跳过文件的校验环节&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-seed-unverified -d/path/to/dir file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;还可以同时播种多个torrent文件&#34;&gt;还可以同时播种多个torrent文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-seed-unverified -d/path/to/dir file1.torrent file2.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过index指定文件名&#34;&gt;通过index指定文件名&lt;/h3&gt;

&lt;p&gt;为了指定bt下载的文件名称，需要使用-S选线来查看torrent文件中的index信息，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;idx|path/length
===+======================
  1|dist/base-2.6.18.iso
   |99.9MiB
---+----------------------
  2|dist/driver-2.6.18.iso
   |169.0MiB
---+----------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的命令可以将dist/base-2.6.18.iso 保存为 /tmp/mydir/base.iso，同时将dist/driver-2.6.18.iso 保存成 /tmp/dir/driver.iso&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --dir=/tmp --index-out=1=mydir/base.iso --index-out=2=dir/driver.iso file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当对http uri中的torrent文件使用–index-out是不成功，它只对本地的torrent文件有效。aria2也不会去记忆–index-out选项内容，在每次的继续下载或播种时都需要手工指明，而且如果没有该选项，它也不会给用户任何提醒，所以需要注意。&lt;/p&gt;

&lt;h3 id=&#34;为进行文件预览进行分片优先下载&#34;&gt;为进行文件预览进行分片优先下载&lt;/h3&gt;

&lt;p&gt;优先下载torrent中所有文件的前1MB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --bt-prioritize-piece=head file.torrent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##使用代理服务器&lt;/p&gt;

&lt;h3 id=&#34;为所有协议-http-s-ftp-设定代理服务器&#34;&gt;为所有协议(HTTP(S)/FTP)设定代理服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --all-proxy=&#39;http://proxy:8080&#39; http://host/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：–all-proxy选项可以被特定的协议选项覆盖，如–http-proxy, –https-proxy 和 –ftp-proxy&lt;/p&gt;

&lt;h3 id=&#34;设置http代理&#34;&gt;设置http代理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --http-proxy=&#39;http://proxy:8080&#39; http://host/file
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用需要认证的代理&#34;&gt;使用需要认证的代理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --http-proxy=&#39;http://proxy:8080&#39; --http-proxy-user=&#39;username&#39; --http-proxy-passwd=&#39;password&#39; http://host/file
aria2c --http-proxy=&#39;http://username:password@proxy:8080&#39; http://host/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：username and password 需要进行%转码，如过username是’myid@domain’，则转码后的结果为：’myid%40domain’。&lt;/p&gt;

&lt;h2 id=&#34;高级的http特性&#34;&gt;高级的http特性：&lt;/h2&gt;

&lt;h3 id=&#34;导入cookie&#34;&gt;导入cookie&lt;/h3&gt;

&lt;p&gt;导入Mozilla/Firefox(1.x/2.x) 和 Netscape格式的cookie&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --load-cookies=cookies.txt http://host/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入Firefox3格式的cookie&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --load-cookies=cookies.sqlite http://host/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;被浏览器或其他程序继续下载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -c -s2 http://host/partiallydownloadedfile.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其他高级特性&#34;&gt;其他高级特性&lt;/h2&gt;

&lt;h3 id=&#34;下载速度限制&#34;&gt;下载速度限制&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --max-download-limit=100K http://host/file
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-v修复受损的下载&#34;&gt;使用-V修复受损的下载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c -V file.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：这个选项只适用于BitTorrent或者带有校验的metalink&lt;/p&gt;

&lt;h3 id=&#34;当下载速度下于某个特定值时放弃下载&#34;&gt;当下载速度下于某个特定值时放弃下载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;aria2c --lowest-speed-limit=10K file.metalink
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;uri的参数化支持&#34;&gt;URI的参数化支持&lt;/h3&gt;

&lt;p&gt;可以使用大括号来表达一组列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -P http://{host1,host2,host3}/file.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用[]来表示一个数字序列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -Z -P http://host/image[000-100].png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：当所有的URI指向不同的文件时，需要使用-Z选项&lt;/p&gt;

&lt;p&gt;甚至可以指定步长&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -Z -P http://host/image[A-Z:2].png
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;时间戳&#34;&gt;时间戳&lt;/h3&gt;

&lt;p&gt;保留源文件时间戳&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -R http://host/file.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载完成后执行特定命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c --on-download-complete=COMMAND http://example.org/file.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另见：&lt;code&gt;–on-download-error&lt;/code&gt;, &lt;code&gt;–on-download-start&lt;/code&gt; 和 &lt;code&gt;–on-download-stop&lt;/code&gt;，或者执行&lt;code&gt;aria2c -h#hook&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;写入/dev/null&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -d /dev -o null --allow-overwrite=true http://example.org/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;–allow-overwrite=true&lt;/code&gt;是为了避免aria2重命名已有的/dev/null&lt;/p&gt;

&lt;h3 id=&#34;输入文件&#34;&gt;输入文件&lt;/h3&gt;

&lt;p&gt;输入文件中可以包括一系列的URI地址，也可以针对同一个资源设置多个URI：不同的URI写在一行并使用tab分割。&lt;br /&gt;
输入文件的每一行都被当作aria2的命令行参数，因此可以受到-Z和-P选项影响&lt;br /&gt;
另外，选项也可以在每行URI的后面设置，更详尽的描述可以在man page的输入文件部分得到。这种选择的含义与命令行选项的含义一致，不过只适用在他们跟随的那个URI上。&lt;/p&gt;

&lt;p&gt;如下，一个uri文件名为uri.txt，其内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://server/file.iso http://mirror/file.iso
  dir=/iso_images
  out=file.img

http://foo/bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果aria2使用 &lt;code&gt;-i uri.txt -d /tmp&lt;/code&gt;,&lt;br /&gt;
那么file.iso就会被保存为/iso_images/file.img，
它的下载源为&lt;a href=&#34;http://server/file.iso&#34;&gt;http://server/file.iso&lt;/a&gt; 和 &lt;a href=&#34;http://mirror/file.iso&#34;&gt;http://mirror/file.iso&lt;/a&gt; ；
而bar文件则是从&lt;a href=&#34;http://foo/bar&#34;&gt;http://foo/bar&lt;/a&gt; 下载并且保存为 /tmp/bar&lt;/p&gt;

&lt;p&gt;*[uri]: 远程或者本地文件地址&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ubuntu常见故障</title>
      <link>http://wixb50.github.io/2015/12/17/ubuntu%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/</link>
      <pubDate>Thu, 17 Dec 2015 13:50:50 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/17/ubuntu%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/</guid>
      <description>

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ssh错误-permission-denied-publickey&#34;&gt;ssh错误: permission denied (publickey)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&#34;ssh错误-permission-denied-publickey&#34;&gt;ssh错误: permission denied (publickey)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;登录远程主机，将/etc/ssh/sshd_config文件中的&lt;code&gt;PasswordAuthentication no&lt;/code&gt; 改为&lt;code&gt;PasswordAuthentication yes&lt;/code&gt;。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;重启sshd服务：&lt;code&gt;/etc/init.d/sshd restart&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;问题解决。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原因：scp是基于ssh的拷贝服务，ssh在没有密钥登录的情况下，禁用了密码登录，故出现如上错误&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker集群系列之－ESXi5.5上搭建CoreOS集群-01</title>
      <link>http://wixb50.github.io/2015/12/15/docker%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97%E4%B9%8Besxi5.5%E4%B8%8A%E6%90%AD%E5%BB%BAcoreos%E9%9B%86%E7%BE%A4-01/</link>
      <pubDate>Tue, 15 Dec 2015 18:10:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/15/docker%E9%9B%86%E7%BE%A4%E7%B3%BB%E5%88%97%E4%B9%8Besxi5.5%E4%B8%8A%E6%90%AD%E5%BB%BAcoreos%E9%9B%86%E7%BE%A4-01/</guid>
      <description>

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#null-link&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#前置条件&#34;&gt;前置条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#安装coreos虚拟机&#34;&gt;安装CoreOS虚拟机&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#choosing-a-channel&#34;&gt;Choosing a Channel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deploying-with-vmware-vsphere-client-55&#34;&gt;Deploying with VMware vSphere Client 5.5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cloud-config&#34;&gt;Cloud-Config&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#需要说明的discovery&#34;&gt;需要说明的&lt;code&gt;discovery&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#logging-in&#34;&gt;Logging in&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-new-machines&#34;&gt;Adding New Machines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#一些有用的coreos命令&#34;&gt;一些有用的CoreOS命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#参考资料&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&#34;前言-null-link&#34;&gt;&lt;a href=&#34;chrome://not-a-link&#34;&gt;前言&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;因为大多数环境都是适配于大公司的云平台，但是也是有折中办法的。CoreOS是一个基于Linux 内核的轻量级操作系统，为了计算机集群的基础设施建设而生，专注于自动化，轻松部署，安全，可靠，规模化。作为一个操作系统，CoreOS 提供了在应用容器内部署应用所需要的基础功能环境以及一系列用于服务发现和配置共享的内建工具。而ESXi专为运行虚拟机、最大限度降低配置要求和简化部署而设计。所以我觉得使用ESXi当作IaaS架构，运行CoreOS集群，这样是可行的。话不多少，开始把。&lt;/p&gt;

&lt;h2 id=&#34;前置条件&#34;&gt;前置条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安装ESXi机器一台：怎么装自己应该知道把，如果因为驱动原因还需要自己定制安装ISO，见Google。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装coreos虚拟机&#34;&gt;安装CoreOS虚拟机&lt;/h2&gt;

&lt;h3 id=&#34;choosing-a-channel&#34;&gt;Choosing a Channel&lt;/h3&gt;

&lt;p&gt;CoreOS is released into alpha, beta, and stable channels. Releases to each channel serve as a release-candidate for the next channel. For example, a bug-free alpha release is promoted bit-for-bit to the beta channel.&lt;/p&gt;

&lt;p&gt;The channel is selected based on the URLs below. Simply replace &lt;code&gt;stable&lt;/code&gt; with &lt;code&gt;alpha&lt;/code&gt; or &lt;code&gt;beta&lt;/code&gt; in the URL. Select 1 of these to download the appropriate image. Read the release notes for specific features and bug fixes in each channel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -LO http://stable.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;curl -LO http://beta.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;curl -LO http://alpha.release.core-os.net/amd64-usr/current/coreos_production_vmware_ova.ova
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;deploying-with-vmware-vsphere-client-5-5&#34;&gt;Deploying with VMware vSphere Client 5.5&lt;/h3&gt;

&lt;p&gt;Use the vSphere Client to deploy the VM as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;in the menu, click “File &amp;gt; Deploy OVF Template…”&lt;/li&gt;
&lt;li&gt;in the wizard, specify the location of the OVA downloaded earlier&lt;/li&gt;
&lt;li&gt;name your VM&lt;/li&gt;
&lt;li&gt;choose “thin provision” for the disk format if you want the disk to grow dynamically&lt;/li&gt;
&lt;li&gt;choose your network settings&lt;/li&gt;
&lt;li&gt;confirm the settings then click “Finish”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;NOTE: Unselect “Power on after deployment” so you have a chance to edit VM settings before powering it up for the first time.&lt;/p&gt;

&lt;p&gt;The last step uploads the files to your ESXi datastore and registers your VM. You can now tweak the VM settings, like memory and virtual cores. These instructions were tested to deploy to an ESXi 5.1 host.&lt;/p&gt;

&lt;p&gt;Before powering it on, you will have to create a cloud-config.&lt;/p&gt;

&lt;h2 id=&#34;cloud-config&#34;&gt;Cloud-Config&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://coreos.com/os/docs/latest/cloud-config.html&#34;&gt;Cloud-Config&lt;/a&gt;是CoreOS内比较重要的概念，可以理解为一种配置CoreOS的方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Providing Cloud-Config with Config-Drive&lt;/strong&gt;&lt;br /&gt;
Cloud-config can be specified by via &lt;a href=&#34;https://github.com/coreos/coreos-cloudinit/blob/master/Documentation/config-drive.md&#34;&gt;config-drive&lt;/a&gt; with the filesystem label &lt;code&gt;config-2&lt;/code&gt;. This is commonly done through whatever interface allows for attaching CD-ROMs or new drives.&lt;/p&gt;

&lt;p&gt;First create a user_data file using the the &lt;a href=&#34;https://coreos.com/os/docs/latest/cloud-config.html&#34;&gt;cloud-config guide&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cloud-config
hostname: core-01  #替换成你的命名的主机名
write_files:
    - path: /etc/systemd/network/static.network
      permissions: 0644  #文件权限,无需改
      content: |
        [Match]
        Name=ens192  #网卡名称,如果你的是别的名称,请改回来

        [Network]
        Address=192.1.1.150/24  #网络配置,同时把下面的IP改掉
        Gateway=192.1.1.1
        DNS=10.11.248.114
        DNS=8.8.4.4
coreos:
    etcd2:
        # generate a new token for each unique cluster from https://discovery.etcd.io/new?size=3
        discovery: https://discovery.etcd.io/&amp;lt;token&amp;gt;  #这里在后面详细讲
        # multi-region and multi-cloud deployments need to use 192.1.1.150
        advertise-client-urls: http://192.1.1.150:2379
        initial-advertise-peer-urls: http://192.1.1.150:2380
        # listen on both the official ports and the legacy ports
        # legacy ports can be omitted if your application doesn&#39;t depend on them
        listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
        listen-peer-urls: http://192.1.1.150:2380,http://192.1.1.150:7001
    fleet:
        public-ip: 192.1.1.150
        metadata: region=europe #metadata,可自定义
    flannel:
        etcd_prefix: /coreos.com/network2
    locksmith:
        endpoint: 192.1.1.150:4001
    update:
        reboot-strategy: etcd-lock
        group: stable
    units:
        - name: etcd2.service #注意是etcd2,第二版哟
          command: start
        - name: fleet.service
          command: start
users:
  - name: &amp;quot;core&amp;quot;  #改成你的用户名,可不是core
    groups:
      - &amp;quot;sudo&amp;quot;
      - &amp;quot;docker&amp;quot;
    ssh-authorized-keys:   
      - ssh-rsa 替换成你的公钥... 
manage_etc_hosts: localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cloud-Config配置信息验证地址&lt;a href=&#34;https://coreos.com/validate/&#34;&gt;https://coreos.com/validate/&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;需要说明的-discovery&#34;&gt;需要说明的&lt;code&gt;discovery&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;　　因为要搭建集群，需要用到服务发现，配置集群的服务发现有两种方式：一种是Static方式，第二种就是Discovery方式了。其中个人不推荐第一种方式，因为每加入一台主机就需要手动配置etcd节点，非常不方便。&lt;br /&gt;
　　第二种Discovery方式是使用远程的服务器辅助服务发现，只需要配置好Discovery的URl就可以自动把新加入的服务器加入集群。其中iscovery服务器可以使用官网提供的，也可以自己搭建(我还没搭建过，这里不介绍了)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl https://discovery.etcd.io/new?size=3  #控制台或者浏览器执行即可,推荐使用size=1,见下面说明
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中有一个&lt;code&gt;size&lt;/code&gt;参数，讲一下我遇到的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有使用size参数结果老是启动不了;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用了&lt;code&gt;size=3&lt;/code&gt;，结果启动主节点，主节点的etcd2就一直等待从节点加入，结果等我去加入它的时候，已经超时了;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;size=1&lt;/code&gt;，没有什么要等待了，过一会就自动启动成功了&lt;code&gt;fleetctl list-machines&lt;/code&gt;也能正常显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，我可能不知道网上哪些一下子启动3个节点是怎么做到的，还是有待学习。但是这里我也有自己的解决方法，就是使用&lt;code&gt;size=1&lt;/code&gt;先运行出来一个只有一台主机的集群，果然可以运行。然后使用主节点的&lt;code&gt;&amp;lt;Token&amp;gt;&lt;/code&gt;再去构建其他节点的&lt;code&gt;Cloud-config&lt;/code&gt;，然后运行，结果果然它自己就能加入到第一个节点里面。&lt;/p&gt;

&lt;p&gt;这里我可能投机取巧了点，但是能运行，也能达到效果就行，哈哈，希望不会有什么bug。&lt;/p&gt;

&lt;p&gt;Finally, to create a cloud-config ISO, use the following commands using the user_data file we just created:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#wrap up a config named user_data in a config drive image:
mkdir -p /tmp/new-drive/openstack/latest
cp user_data /tmp/new-drive/openstack/latest/user_data
mkisofs -R -V config-2 -o configdrive-01.iso /tmp/new-drive
rm -r /tmp/new-drive

#transform iso file to datastore
#scp configdrive-01.iso root@192.1.1.132:/vmfs/volumes/datastore1/ISO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the config-drive standard was originally an OpenStack feature, which is why you’ll see strings containing openstack. This filepath needs to be retained, although CoreOS supports config-drive on all platforms.&lt;/p&gt;

&lt;p&gt;Note: The $private_ipv4 and $public_ipv4 substitution variables referenced in other documents are not supported on VMware. You can replace all these variables by the (static) IP of the CoreOS server you’re setting up. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;coreos:
  etcd2:
    # generate a new token for each unique cluster from https://discovery.etcd.io/new?size=3
    discovery: https://discovery.etcd.io/&amp;lt;token&amp;gt;
    # multi-region and multi-cloud deployments need to use $public_ipv4
    advertise-client-urls: http://$public_ipv4:2379
    initial-advertise-peer-urls: http://$private_ipv4:2380
    # listen on both the official ports and the legacy ports
    # legacy ports can be omitted if your application doesn&#39;t depend on them
    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
    listen-peer-urls: http://$private_ipv4:2380,http://$private_ipv4:7001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;becomes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;coreos:
  etcd2:
    # generate a new token for each unique cluster from https://discovery.etcd.io/new?size=3
    discovery: https://discovery.etcd.io/&amp;lt;token&amp;gt;
    # multi-region and multi-cloud deployments need to use $public_ipv4
    advertise-client-urls: http://192.168.0.100:2379
    initial-advertise-peer-urls: http://192.168.0.100:2380
    # listen on both the official ports and the legacy ports
    # legacy ports can be omitted if your application doesn&#39;t depend on them
    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
    listen-peer-urls: http://192.168.0.100:2380,http://192.168.0.100:7001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attach the ISO to the VM as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;edit the settings of the CoreOS VM&lt;/li&gt;
&lt;li&gt;in the dialog, select “CD/DVD drive 1” in the device list&lt;/li&gt;
&lt;li&gt;select “connect at power on”&lt;/li&gt;
&lt;li&gt;choose “datastore ISO file” as the device type&lt;/li&gt;
&lt;li&gt;browse the datastore and select your config drive ISO&lt;/li&gt;
&lt;li&gt;confirm the changes and click “OK”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;NOTE:如果发现ip不对，可查看配置文件，Maybe重启一下也可以解决哟。&lt;/p&gt;

&lt;h2 id=&#34;logging-in&#34;&gt;Logging in&lt;/h2&gt;

&lt;p&gt;可以查看ESXi控制台CoreOS的IP，但是静态的自己已经知道了。&lt;/p&gt;

&lt;p&gt;Now you can login using your SSH key or password set in your cloud-config，可以登录就没必要折腾下步了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh core@192.1.1.150
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, if the cloud-config fails to apply you can append coreos.autologin to the kernel parameters on boot, the console won’t prompt for a password. This is handy for debugging.&lt;/p&gt;

&lt;p&gt;When GNU GRUB appears at boot, make sure CoreOS default is selected and press e, then add coreos.autologin after &lt;code&gt;$linux_append&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Before&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holysh1t.net/vgwtest/coreosstuff/grubautologin1.png&#34; alt=&#34;之前的启动界面&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;After&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.holysh1t.net/vgwtest/coreosstuff/grubautologin2.png&#34; alt=&#34;之前的启动界面&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;When coreos.autologin is added, press &lt;code&gt;CTRL+X&lt;/code&gt; to boot CoreOS with these parameters. Note that the next time autologin will be disabled again as these kernel parameters aren’t persistent.&lt;/p&gt;

&lt;p&gt;You can now manually apply the cloud-config by using the following command in the console of CoreOS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo /usr/bin/coreos-cloudinit --from-file /media/configdrive/openstack/latest/user_data
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-new-machines&#34;&gt;Adding New Machines&lt;/h2&gt;

&lt;p&gt;按照前面所说的，如果需要把其他CoreOS加入集群，只需要把Discovery URL改成原来集群地址即可自动加入了，是不是很方便呀。&lt;/p&gt;

&lt;p&gt;If you forgot which discovery URL you used, you may look it up on one of the members of the cluster. Use the following grep command on one of your existing machines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep DISCOVERY /run/systemd/system/etcd2.service.d/20-cloudinit.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will see a line the contains the original discovery URL, like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Environment=&amp;quot;ETCD_DISCOVERY=https://discovery.etcd.io/575302f03f4fb2db82e81ea2abca55e9&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Your basic CoreOS cluster is set up, and now you can move on to testing with it!&lt;/p&gt;

&lt;h2 id=&#34;一些有用的coreos命令&#34;&gt;一些有用的CoreOS命令&lt;/h2&gt;

&lt;p&gt;查看当前集群所有machines&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fleetctl list-machines
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看服务运行状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;systemctl -l status etcd2  #其中-l参数可选
systemctl -l status fleet
systemctl -l status docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看服务的运行日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;journalctl -u etcd2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coreos.com/&#34;&gt;CoreOS官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/cn/cloud/library/1505_gutb_coreos/&#34;&gt;在 ESXi5 上部署 CoreOS 集群解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tuicool.com/m/articles/zyaAbyJ&#34;&gt;平台云基石-CoreOS之集群篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stable.release.core-os.net/&#34;&gt;Download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.holysh1t.net/vgwtest/coreosstuff/coreos-vmware-esxi-setup.html&#34;&gt;Running CoreOS on VMware ESXi 5.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>快速搭建CoreOS集群</title>
      <link>http://wixb50.github.io/2015/12/12/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcoreos%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Sat, 12 Dec 2015 15:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/12/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAcoreos%E9%9B%86%E7%BE%A4/</guid>
      <description>

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#前言&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#准备工作&#34;&gt;准备工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#配置工作&#34;&gt;配置工作&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#安装-vagrant-and-virtualbox&#34;&gt;安装 Vagrant and VirtualBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#从coreos官方代码库获取基本配置，并进行修改&#34;&gt;从CoreOS官方代码库获取基本配置，并进行修改&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#启动集群&#34;&gt;启动集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#测试集群&#34;&gt;测试集群&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&#34;前言-null&#34;&gt;&lt;a href=&#34;null&#34;&gt;前言&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;第一次接触CoreOS这样的分布式平台，运行一个集群看起来好像一个很复杂的任务，这里我们给你展示在本地快速搭建一个CoreOS集群环境是多么的容易。&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;本地的机器上已经安装了最新版本的Virtualbox, Vagrant 和 git。&lt;/p&gt;

&lt;h2 id=&#34;配置工作&#34;&gt;配置工作&lt;/h2&gt;

&lt;h3 id=&#34;安装-vagrant-and-virtualbox&#34;&gt;安装 Vagrant and VirtualBox&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.vagrantup.com/&#34;&gt;vagrant&lt;/a&gt; 和 &lt;a href=&#34;https://www.virtualbox.org/wiki/Downloads&#34;&gt;virtualbox&lt;/a&gt;都是直接下载双击安装的，具体安装教程看官网。&lt;/p&gt;

&lt;h3 id=&#34;从coreos官方代码库获取基本配置-并进行修改&#34;&gt;从CoreOS官方代码库获取基本配置，并进行修改&lt;/h3&gt;

&lt;p&gt;首先，获取模板配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/coreos/coreos-vagrant
cd coreos-vagrant
cp user-data.sample user-data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取新的token&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl https://discovery.etcd.io/new
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用新的token配置到user-data文件如下，&lt;a href=&#34;https://coreos.com/os/docs/latest/booting-on-vagrant.html&#34;&gt;官网示例&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#cloud-config

coreos:
  etcd2:
    # generate a new token for each unique cluster from https://discovery.etcd.io/new?size=3
    # specify the initial size of your cluster with ?size=X
    # WARNING: replace each time you &#39;vagrant destroy&#39;
    discovery: https://discovery.etcd.io/&amp;lt;token&amp;gt;
    # multi-region and multi-cloud deployments need to use $public_ipv4
    advertise-client-urls: http://$private_ipv4:2379,http://$private_ipv4:4001
    initial-advertise-peer-urls: http://$private_ipv4:2380
    # listen on both the official ports and the legacy ports
    # legacy ports can be omitted if your application doesn&#39;t depend on them
    listen-client-urls: http://0.0.0.0:2379,http://0.0.0.0:4001
    listen-peer-urls: http://$private_ipv4:2380
  fleet:
    public-ip: $public_ipv4
  flannel:
    interface: $public_ipv4
  units:
    - name: etcd2.service
      command: start
    - name: fleet.service
      command: start
    - name: flanneld.service
      drop-ins:
      - name: 50-network-config.conf
        content: |
          [Service]
          ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config &#39;{ &amp;quot;Network&amp;quot;: &amp;quot;10.1.0.0/16&amp;quot; }&#39;
      # Uncomment line above if you want to use flannel in your installation.
      # command: start
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;提示：编辑完毕后，请到[&lt;a href=&#34;http://codebeautify.org/yaml-validator][]校验下yaml文件格式是否正确。&#34;&gt;http://codebeautify.org/yaml-validator][]校验下yaml文件格式是否正确。&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动集群&#34;&gt;启动集群&lt;/h2&gt;

&lt;p&gt;默认情况下，CoreOS Vagrantfile 将会启动单机。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们需要复制并修改config.rb.sample文件.&lt;/p&gt;

&lt;p&gt;复制文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp config.rb.sample config.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 config.rb 文件，配置 $num_instances 和 $update_channel 这两个参数。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Official CoreOS channel from which updates should be downloade
$num_instances=3  ## 表示我们要创建3台主机
# Official CoreOS channel from which updates should be downloade
$update_channel=&#39;stable&#39;  ## 表示使用的coreos版本，有：&#39;stable&#39;、&#39;beta&#39;、&#39;alpha&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;提示：如果国内下载比较慢，可以先事先下载好&lt;code&gt;coreos_production_vagrant.box&lt;/code&gt;，添加到vagrant的box里面。注意更改名字为&amp;raquo;coreos-stable|coreos-beta|coreos-alpha&amp;raquo;，和你上面填写的对应。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;启动集群&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;添加ssh的公匙&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-add ~/.vagrant.d/insecure_private_key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接集群中的第一台机器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant ssh core-01 -- -A
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;测试集群&#34;&gt;测试集群&lt;/h2&gt;

&lt;p&gt;使用fleet来查看机器运行状况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fleetctl list-machines
=&amp;gt;
MACHINE   IP            METADATA
517d1c7d... 172.17.8.101  -
cb35b356... 172.17.8.103  -
17040743... 172.17.8.102  -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上类似的信息，恭喜，本地基于三台机器的集群已经成功启动，可能需要等个几秒才会完全启动。&lt;/p&gt;

&lt;p&gt;那么之后你就可以基于CoreOS的三大工具做任务分发，分布式存储等很多功能了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker Operation</title>
      <link>http://wixb50.github.io/2015/12/11/docker-operation/</link>
      <pubDate>Fri, 11 Dec 2015 18:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/11/docker-operation/</guid>
      <description>

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#normal-commander&#34;&gt;normal commander&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker-使用代理连接-docker-hub&#34;&gt;Docker 使用代理连接 Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#存出或者载入镜像&#34;&gt;存出或者载入镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#批量操作docker-commander&#34;&gt;批量操作docker commander.&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stop-all-containers&#34;&gt;Stop all containers.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#remove-all-stopped-containers&#34;&gt;Remove all stopped containers.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#remove-all-untagged-images&#34;&gt;Remove all untagged images&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#remove-all-images&#34;&gt;Remove all images&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&#34;normal-commander&#34;&gt;normal commander&lt;/h2&gt;

&lt;h3 id=&#34;docker-使用代理连接-docker-hub&#34;&gt;Docker 使用代理连接 Docker Hub&lt;/h3&gt;

&lt;p&gt;如果你的宿主操作系统是 linux 那方法就很简单了，直接通过命令来启动服务即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo HTTP_PROXY=10.125.156.21:8118 docker -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是只是临时使用可以用下面语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo HTTP_PROXY=10.125.156.21:8118 docker pull node
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;存出或者载入镜像&#34;&gt;存出或者载入镜像&lt;/h3&gt;

&lt;p&gt;存出镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker save -o ubuntu_14.04.tar ubuntu:14.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;载入镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker load &amp;lt; ubuntu_14.04.tar
#or
sudo docker --input ubuntu_14.04.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;批量操作docker-commander&#34;&gt;批量操作docker commander.&lt;/h2&gt;

&lt;p&gt;NOTE: &lt;code&gt;sudo&lt;/code&gt;maybe.&lt;/p&gt;

&lt;h4 id=&#34;stop-all-containers&#34;&gt;Stop all containers.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;remove-all-stopped-containers&#34;&gt;Remove all stopped containers.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;remove-all-untagged-images&#34;&gt;Remove all untagged images&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi $(docker images | grep &amp;quot;^&amp;lt;none&amp;gt;&amp;quot; | awk &amp;quot;{print $3}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;remove-all-images&#34;&gt;Remove all images&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi $(docker images | grep \ | awk &#39;{print $3}&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ubuntu更改源设置</title>
      <link>http://wixb50.github.io/2015/12/08/ubuntu%E6%9B%B4%E6%94%B9%E6%BA%90%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Tue, 08 Dec 2015 16:43:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/08/ubuntu%E6%9B%B4%E6%94%B9%E6%BA%90%E8%AE%BE%E7%BD%AE/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;首先备份源列表：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;而后用vim或其他编辑器打开:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo vim /etc/apt/sources.list
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从下面列表中选择合适的源，替换掉文件中所有的内容，保存编辑好的文件:&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;red&#34;&gt;注意：一定要选对版本&lt;/font&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，刷新列表&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;附上ubuntu14.04源：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;网易163源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜狐源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse
deb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse
deb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse
deb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse
deb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse
deb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse
deb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;oschina源：
&lt;code&gt;
deb http://mirrors.oschina.net/ubuntu/ trusty main restricted universe multiverse
deb http://mirrors.oschina.net/ubuntu/ trusty-backports main restricted universe multiverse
deb http://mirrors.oschina.net/ubuntu/ trusty-proposed main restricted universe multiverse
deb http://mirrors.oschina.net/ubuntu/ trusty-security main restricted universe multiverse
deb http://mirrors.oschina.net/ubuntu/ trusty-updates main restricted universe multiverse
deb-src http://mirrors.oschina.net/ubuntu/ trusty main restricted universe multiverse
deb-src http://mirrors.oschina.net/ubuntu/ trusty-backports main restricted universe multiverse
deb-src http://mirrors.oschina.net/ubuntu/ trusty-proposed main restricted universe multiverse
deb-src http://mirrors.oschina.net/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://mirrors.oschina.net/ubuntu/ trusty-updates main restricted universe multiverse
&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ubuntu搭建远程桌面服务器</title>
      <link>http://wixb50.github.io/2015/12/06/ubuntu%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Sun, 06 Dec 2015 17:27:25 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/06/ubuntu%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>&lt;p&gt;1、安装xrdp和vnc4server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install xrdp
sudo apt-get install vnc4server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tightvncserver在ubuntu14.04下面是不用装的，如果连接的是ubuntu12.04的话。是需要安装的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install tightvncserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、安装xfce4的桌面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install xubuntu-desktop
echo &amp;quot;xfce4-session&amp;quot; &amp;gt;~/.xsession  #在需要远程登录的用户下执行一遍即可
sudo service xrdp restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果无法远程连接成功，记得在终端下执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新启动系统。&lt;/p&gt;

&lt;p&gt;Windows下的操作：&lt;br /&gt;
使用&amp;raquo;窗口键+R&amp;raquo;打开&amp;raquo;运行对话框&amp;raquo;&amp;ndash;&amp;gt;输入&amp;raquo;mstsc&amp;raquo;&amp;ndash;&amp;gt;回车&amp;ndash;&amp;gt;输入Ubuntu主机的IP地址&amp;ndash;&amp;gt;&amp;laquo;连接&amp;raquo;。在Ubuntu下可以通过“ifconfig”获得本机网络连接的概况，其中包括IP地址。
填上正确的IP地址，按回车，会出现一个登陆框，我们选择“sesman-Xvnc”这个，然后输入你的Ubuntu的用户名和密码，OK！&lt;/p&gt;

&lt;p&gt;后记：使用这种方法连上Ubuntu还有个问题，就是键盘的快捷键会有点小混乱。此时断开远程桌面，在Ubuntu的实体机器上，打开管理键盘快捷键，将带有“windows”键，ubunntu显示是“mod5”键（好像是类似的，记不清了）的快捷键组合删掉即可。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>nodejs linux安装与卸载</title>
      <link>http://wixb50.github.io/2015/12/06/nodejs-linux%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</link>
      <pubDate>Sun, 06 Dec 2015 12:51:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/12/06/nodejs-linux%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/</guid>
      <description>

&lt;h2 id=&#34;node-js-安装-卸载-升级&#34;&gt;Node.js 安装、卸载、升级&lt;/h2&gt;

&lt;h3 id=&#34;安装-源码下载&#34;&gt;安装、源码下载&lt;/h3&gt;

&lt;p&gt;下载最新版本node的源代码：&lt;a href=&#34;https://nodejs.org/en/download/&#34;&gt;下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解压下载文件：&lt;br /&gt;
&lt;code&gt;tar -xzvf node-v4.2.1.tar.gz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;切换工作目录至源代码目录：&lt;br /&gt;
&lt;code&gt;cd node-v4.2.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;configure&lt;/code&gt;配置安装文件：&lt;br /&gt;
&lt;code&gt;./configure&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;make编译码代码：  &lt;em&gt;(编译Node源码时间较长，我编译用了大约40分左右。)&lt;/em&gt;&lt;br /&gt;
&lt;code&gt;make&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;make install安装：&lt;br /&gt;
&lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看安装：&lt;em&gt;(显示版本号)&lt;/em&gt;&lt;br /&gt;
&lt;code&gt;node -v&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;卸载&#34;&gt;卸载&lt;/h3&gt;

&lt;p&gt;保留编译完成的源码包，或者自己再重新编译生成个&lt;/p&gt;

&lt;p&gt;干掉make install命令时装进去的文件,需要管理员身份&lt;br /&gt;
&lt;code&gt;sudo make uninstall&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;只删除make时产生的临时文件：&lt;br /&gt;
&lt;code&gt;make clean&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同时删除configure和make产生的临时文件&lt;br /&gt;
&lt;code&gt;make distclean&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;升级node版本&#34;&gt;升级Node版本&lt;/h3&gt;

&lt;p&gt;直接下载源码重新编译，安装。（覆盖了旧的版本）&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;Ps&lt;/h2&gt;

&lt;p&gt;&lt;small&gt;也同样适用与其他linux平台编译安装软件。&lt;/small&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang使用http client发起get和post请求</title>
      <link>http://wixb50.github.io/2015/11/23/golang%E4%BD%BF%E7%94%A8http-client%E5%8F%91%E8%B5%B7get%E5%92%8Cpost%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Mon, 23 Nov 2015 22:00:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/11/23/golang%E4%BD%BF%E7%94%A8http-client%E5%8F%91%E8%B5%B7get%E5%92%8Cpost%E8%AF%B7%E6%B1%82/</guid>
      <description>

&lt;p&gt;需要导入的包&lt;code&gt;&amp;quot;io/ioutil&amp;quot;&lt;/code&gt;、&lt;code&gt;&amp;quot;net/http&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;get请求&#34;&gt;get请求&lt;/h3&gt;

&lt;p&gt;get请求可以直接http.Get方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func httpGet() {
    resp, err := http.Get(&amp;quot;http://www.01happy.com/demo/accept.php?id=1&amp;quot;)
    if err != nil {
        // handle error
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        // handle error
    }

    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post请求&#34;&gt;post请求&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用http.Post方式&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func httpPost() {
    resp, err := http.Post(&amp;quot;http://www.01happy.com/demo/accept.php&amp;quot;,
        &amp;quot;application/x-www-form-urlencoded&amp;quot;,
        strings.NewReader(&amp;quot;name=cjb&amp;quot;))
    if err != nil {
        fmt.Println(err)
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        // handle error
    }

    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tips：使用这个方法的话，第二个参数要设置成”application/x-www-form-urlencoded”，否则post参数无法传递。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用http.PostForm方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func httpPostForm() {
    resp, err := http.PostForm(&amp;quot;http://www.01happy.com/demo/accept.php&amp;quot;,
        url.Values{&amp;quot;key&amp;quot;: {&amp;quot;Value&amp;quot;}, &amp;quot;id&amp;quot;: {&amp;quot;123&amp;quot;}})

    if err != nil {
        // handle error
    }

    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        // handle error
    }

    fmt.Println(string(body))

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复杂的请求&#34;&gt;复杂的请求&lt;/h3&gt;

&lt;p&gt;有时需要在请求的时候设置头参数、cookie之类的数据，就可以使用http.Do方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func httpDo() {
    client := &amp;amp;http.Client{}

    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, &amp;quot;http://www.01happy.com/demo/accept.php&amp;quot;, strings.NewReader(&amp;quot;name=cjb&amp;quot;))
    if err != nil {
        // handle error
    }

    req.Header.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)
    req.Header.Set(&amp;quot;Cookie&amp;quot;, &amp;quot;name=anny&amp;quot;)

    resp, err := client.Do(req)

    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        // handle error
    }

    fmt.Println(string(body))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同上面的post请求，必须要设定Content-Type为application/x-www-form-urlencoded，post参数才可正常传递.&lt;/p&gt;

&lt;h3 id=&#34;head请求&#34;&gt;Head请求&lt;/h3&gt;

&lt;p&gt;发起head请求可以直接使用http client的head方法。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang资料</title>
      <link>http://wixb50.github.io/2015/11/22/golang%E8%B5%84%E6%96%99/</link>
      <pubDate>Sun, 22 Nov 2015 22:00:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/11/22/golang%E8%B5%84%E6%96%99/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;WindowsCrossCompiling:&lt;a href=&#34;https://github.com/golang/go/wiki/WindowsCrossCompiling&#34;&gt;Building windows go programs on linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mysql 安装配置</title>
      <link>http://wixb50.github.io/2015/11/20/mysql-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 20 Nov 2015 19:32:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/11/20/mysql-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;p&gt;1.更新源&lt;br /&gt;
&lt;code&gt;source /etc/apt/source.list&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;br /&gt;
2.在Ubuntu14.04下安装mysql：(还是从mysql官网下载安装包安装吧)&lt;br /&gt;
&lt;code&gt;sudo apt-get install mysql-server&lt;/code&gt;&lt;br /&gt;
3.在目录/etc/mysql下打开my.cnf，用vim编辑，找到&lt;br /&gt;
&lt;code&gt;bind-address   =127.0.0.1&lt;/code&gt;&lt;br /&gt;
改为：&lt;br /&gt;
&lt;code&gt;bind-address   =0.0.0.0&lt;/code&gt;或者直接将上句注释掉&lt;br /&gt;
4.使用root账户登录到Mysql数据库：&lt;br /&gt;
&lt;code&gt;mysql -u root -p&lt;/code&gt;&lt;br /&gt;
使用命令：&lt;br /&gt;
&lt;code&gt;use mysql;&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;select host, user, password from user&lt;/code&gt;可以查看到当前可以连接到该服务器的用户&lt;br /&gt;
在mysql&amp;gt;输入：&lt;br /&gt;
&lt;code&gt;grant all on *.* to root@&#39;%&#39; identified by &#39;123&#39;&lt;/code&gt;&lt;br /&gt;
注：&lt;br /&gt;
* root是用户名
* passwd是连接密码&lt;br /&gt;
&lt;code&gt;flush privileges;&lt;/code&gt;  # 刷新权限表&lt;br /&gt;
5.最后在远端可以进行远程登录：&lt;br /&gt;
* 用户名：root
* 密码：123
* 端口：3306&lt;br /&gt;
完成！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>gulp 资源教程集合</title>
      <link>http://wixb50.github.io/2015/11/20/gulp-%E8%B5%84%E6%BA%90%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88/</link>
      <pubDate>Fri, 20 Nov 2015 18:51:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/11/20/gulp-%E8%B5%84%E6%BA%90%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88/</guid>
      <description>

&lt;h1 id=&#34;gulp-资源教程集合&#34;&gt;gulp 资源教程集合&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;1.&lt;a href=&#34;http://www.w3ctech.com/topic/134&#34;&gt;Gulp开发教程（翻译）&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&#34;http://gulpjs.com/plugins/&#34;&gt;Gulp插件搜索地址&lt;/a&gt;&lt;br /&gt;
3.&lt;a href=&#34;http://www.gulpjs.com.cn/&#34;&gt;gulp中文网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;####项目例子&lt;br /&gt;
- &lt;a href=&#34;https://github.com/Swiip/generator-gulp-angular&#34;&gt;generator-gulp-angular&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&#34;https://github.com/yeoman/generator-angular#app&#34;&gt;generator-angular&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>golang排序实现 sort接口实现</title>
      <link>http://wixb50.github.io/2015/11/20/golang%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0-sort%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 20 Nov 2015 18:32:33 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.github.io/2015/11/20/golang%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0-sort%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;sort.Interface接口有三个方法,给自己的struct实现这三个方法,然后用将自己的结构体传给sort.Sort方法就排序完成.&lt;/p&gt;

&lt;p&gt;sort包也有几个常用的方法sort.Float64Slice sort.IntSlise sort.StringSlise&lt;/p&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sort&amp;quot;
)

type MapSorter []Item

type Item struct {
    Key string
    Val int64
}

func NewMapSorter(m map[string]int64) MapSorter {
    ms := make(MapSorter, 0, len(m))

    for k, v := range m {
        ms = append(ms, Item{k, v})
    }

    return ms
}

func (ms MapSorter) Len() int {
    return len(ms)
}

func (ms MapSorter) Less(i, j int) bool {
    return ms[i].Val &amp;lt; ms[j].Val // 按值排序
    //return ms[i].Key &amp;lt; ms[j].Key // 按键排序
}

func (ms MapSorter) Swap(i, j int) {
    ms[i], ms[j] = ms[j], ms[i]
}

func main(){
    m  := map[string]int64 {
        &amp;quot;e&amp;quot;: 10,
        &amp;quot;a&amp;quot;: 2,
        &amp;quot;d&amp;quot;: 15,
        &amp;quot;c&amp;quot;: 8,
        &amp;quot;f&amp;quot;: 1,
        &amp;quot;b&amp;quot;: 12,
    }

    ms := NewMapSorter(m)
    sort.Sort(ms)

    for _, item := range ms {
        fmt.Printf(&amp;quot;%s:%d\n&amp;quot;, item.Key, item.Val)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cloud on Wixb blog</title>
    <link>http://wixb50.coding.me/categories/cloud/</link>
    <description>Recent content in Cloud on Wixb blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>wixb50@gmail.com (Wixb)</managingEditor>
    <webMaster>wixb50@gmail.com (Wixb)</webMaster>
    <copyright>(c) 2015 wixb.All rights reserved.</copyright>
    <lastBuildDate>Fri, 17 Jun 2016 19:38:38 +0800</lastBuildDate>
    <atom:link href="http://wixb50.coding.me/categories/cloud/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>docker入门</title>
      <link>http://wixb50.coding.me/2016/06/17/docker%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 17 Jun 2016 19:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.coding.me/2016/06/17/docker%E5%85%A5%E9%97%A8/</guid>
      <description>

&lt;h1 id=&#34;前言&#34;&gt;&lt;a href=&#34;#&#34;&gt;前言&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;虚拟化&lt;/strong&gt;，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt; 是个开源项目，它彻底释放了虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本，同时让应用的部署、测试和分发都变得前所未有的高效和轻松。Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;

&lt;p&gt;如果把虚拟化比做OS，则Docker是OS上的再一层抽象，它运行的容器可以看作一个进程级别的虚拟机。启动、运行、安装都是只通过一个命令就能解决。对于搭建集群和不可变基础设施是非常有利的。&lt;/p&gt;

&lt;h1 id=&#34;基本概念&#34;&gt;基本概念&lt;/h1&gt;

&lt;p&gt;Docker 包括三个基本概念&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;镜像（Image）&lt;/li&gt;
&lt;li&gt;容器（Container）&lt;/li&gt;
&lt;li&gt;仓库（Repository）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解了这三个概念，就理解了 Docker 的整个生命周期。&lt;/p&gt;

&lt;h2 id=&#34;镜像&#34;&gt;镜像&lt;/h2&gt;

&lt;p&gt;Docker 镜像（Image）就是一个只读的模板，相当于操作系统(OS)安装的Ghost。&lt;/p&gt;

&lt;p&gt;例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。&lt;/p&gt;

&lt;p&gt;镜像可以用来创建 Docker 容器。&lt;/p&gt;

&lt;p&gt;Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。&lt;/p&gt;

&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;

&lt;p&gt;Docker 利用容器（Container）来运行应用。&lt;/p&gt;

&lt;p&gt;容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。同时容器也可以暴露相应的“端口”和挂载“容器卷”，分别用以网络和存储共享。&lt;/p&gt;

&lt;p&gt;可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。&lt;/p&gt;

&lt;h2 id=&#34;仓库&#34;&gt;仓库&lt;/h2&gt;

&lt;p&gt;仓库（Repository）是集中存放镜像文件的场所。&lt;/p&gt;

&lt;p&gt;仓库分为公开仓库（Public）和私有仓库（Private）两种形式。&lt;/p&gt;

&lt;p&gt;最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。&lt;/p&gt;

&lt;p&gt;国内的公开仓库包括 时速云 、网易云 等，可以提供大陆用户更稳定快速的访问。&lt;/p&gt;

&lt;p&gt;当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。&lt;/p&gt;

&lt;p&gt;*注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;Docker 目前只能安装在 64 位平台上，并且要求内核版本不低于 3.10，实际上内核越新越好，过低的内核版本容易造成功能的不稳定。&lt;/p&gt;

&lt;p&gt;快捷安装脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;常用命令&#34;&gt;常用命令&lt;/h1&gt;

&lt;h2 id=&#34;镜像命令&#34;&gt;镜像命令&lt;/h2&gt;

&lt;p&gt;获取镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker pull ubuntu:12.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载过程中，会输出获取镜像的每一层信息。
该命令实际上相当于 $ sudo docker pull registry.hub.docker.com/ubuntu:12.04 命令，即从注册服务器 registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。&lt;/p&gt;

&lt;p&gt;使用 docker images 显示本地已有的镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除本地的镜像，可以使用 docker rmi 命令。注意 docker rm 命令是移除容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker rmi training/sinatra
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;容器命令&#34;&gt;容器命令&lt;/h2&gt;

&lt;p&gt;基于一个images，新建并启动一个容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run ubuntu:14.04 /bin/echo &#39;Hello world&#39;
Hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有启动的容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有的容器(包括未启动的)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据容器id，或者name启动，重启，停止容器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker start/restart {containerID|containerName}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run -d ubuntu:14.04 /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot;
77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时容器会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果可以用docker logs 查看)。&lt;/p&gt;

&lt;p&gt;容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run -d -p 5000:5000 training/webapp python app.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口.&lt;/p&gt;

&lt;h1 id=&#34;docker进阶&#34;&gt;Docker进阶&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;数据卷管理&lt;/li&gt;
&lt;li&gt;Dockerfile&lt;/li&gt;
&lt;li&gt;私有仓库&lt;/li&gt;
&lt;li&gt;集群项目

&lt;ul&gt;
&lt;li&gt;Docker compose、Docker machine、Docker swarm&lt;/li&gt;
&lt;li&gt;Kubernetes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker Operation</title>
      <link>http://wixb50.coding.me/2015/12/11/docker-operation/</link>
      <pubDate>Fri, 11 Dec 2015 18:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.coding.me/2015/12/11/docker-operation/</guid>
      <description>

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;!-- MarkdownTOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#normal-commander&#34;&gt;normal commander&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#docker-使用代理连接-docker-hub&#34;&gt;Docker 使用代理连接 Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#存出或者载入镜像&#34;&gt;存出或者载入镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#批量操作docker-commander&#34;&gt;批量操作docker commander.&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stop-all-containers&#34;&gt;Stop all containers.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#remove-all-stopped-containers&#34;&gt;Remove all stopped containers.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#remove-all-untagged-images&#34;&gt;Remove all untagged images&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#remove-all-images&#34;&gt;Remove all images&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;h2 id=&#34;normal-commander&#34;&gt;normal commander&lt;/h2&gt;

&lt;h3 id=&#34;docker-使用代理连接-docker-hub&#34;&gt;Docker 使用代理连接 Docker Hub&lt;/h3&gt;

&lt;p&gt;如果你的宿主操作系统是 linux 那方法就很简单了，直接通过命令来启动服务即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo HTTP_PROXY=10.125.156.21:8118 docker -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是只是临时使用可以用下面语句&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo HTTP_PROXY=10.125.156.21:8118 docker pull node
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;存出或者载入镜像&#34;&gt;存出或者载入镜像&lt;/h3&gt;

&lt;p&gt;存出镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker save -o ubuntu_14.04.tar ubuntu:14.04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;载入镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker load &amp;lt; ubuntu_14.04.tar
#or
sudo docker --input ubuntu_14.04.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;批量操作docker-commander&#34;&gt;批量操作docker commander.&lt;/h2&gt;

&lt;p&gt;NOTE: &lt;code&gt;sudo&lt;/code&gt;maybe.&lt;/p&gt;

&lt;h4 id=&#34;stop-all-containers&#34;&gt;Stop all containers.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker stop $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;remove-all-stopped-containers&#34;&gt;Remove all stopped containers.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;remove-all-untagged-images&#34;&gt;Remove all untagged images&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi $(docker images | grep &amp;quot;^&amp;lt;none&amp;gt;&amp;quot; | awk &amp;quot;{print $3}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;remove-all-images&#34;&gt;Remove all images&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;docker rmi $(docker images | grep \ | awk &#39;{print $3}&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>etcd安装</title>
      <link>http://wixb50.coding.me/2015/11/03/etcd%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 03 Nov 2015 16:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.coding.me/2015/11/03/etcd%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;p&gt;##目录
&lt;!-- MarkdownTOC --&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#二进制文件方式下载&#34;&gt;二进制文件方式下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#docker-镜像方式下载&#34;&gt;Docker 镜像方式下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /MarkdownTOC --&gt;

&lt;blockquote&gt;
&lt;p&gt;etcd 基于 Go 语言实现，因此，用户可以从 项目主页 下载源代码自行编译，也可以下载编译好的二进制文件，甚至直接使用制作好的 Docker 镜像文件来体验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;二进制文件方式下载&#34;&gt;二进制文件方式下载&lt;/h3&gt;

&lt;p&gt;编译好的二进制文件都在 github.com/coreos/etcd/releases 页面，用户可以选择需要的版本，或通过下载工具下载。&lt;/p&gt;

&lt;p&gt;例如，下面的命令使用 curl 工具下载压缩包，并解压。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -L  https://github.com/coreos/etcd/releases/download/v2.0.0-rc.1/etcd-v2.0.0-rc.1-linux-amd64.tar.gz -o etcd-v2.0.0-rc.1-linux-amd64.tar.gz
tar xzvf etcd-v2.0.0-rc.1-linux-amd64.tar.gz
cd etcd-v2.0.0-rc.1-linux-amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解压后，可以看到文件包括&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
etcd  etcdctl  etcd-migrate  README-etcdctl.md  README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 etcd 是服务主文件，etcdctl 是提供给用户的命令客户端，etcd-migrate 负责进行迁移。&lt;/p&gt;

&lt;p&gt;推荐通过下面的命令将三个文件都放到系统可执行目录 /usr/local/bin/ 或 /usr/bin/。&lt;br /&gt;
&lt;code&gt;$ sudo cp etcd* /usr/local/bin/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;运行 etcd，将默认组建一个两个节点的集群。数据库服务端默认监听在 2379 和 4001 端口，etcd 实例监听在 2380 和 7001 端口。显示类似如下的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./etcd
2014/12/31 14:52:09 no data-dir provided, using default data-dir ./default.etcd
2014/12/31 14:52:09 etcd: listening for peers on http://localhost:2380
2014/12/31 14:52:09 etcd: listening for peers on http://localhost:7001
2014/12/31 14:52:09 etcd: listening for client requests on http://localhost:2379
2014/12/31 14:52:09 etcd: listening for client requests on http://localhost:4001
2014/12/31 14:52:09 etcdserver: name = default
2014/12/31 14:52:09 etcdserver: data dir = default.etcd
2014/12/31 14:52:09 etcdserver: snapshot count = 10000
2014/12/31 14:52:09 etcdserver: advertise client URLs = http://localhost:2379,http://localhost:4001
2014/12/31 14:52:09 etcdserver: initial advertise peer URLs = http://localhost:2380,http://localhost:7001
2014/12/31 14:52:09 etcdserver: initial cluster = default=http://localhost:2380,default=http://localhost:7001
2014/12/31 14:52:10 etcdserver: start member ce2a822cea30bfca in cluster 7e27652122e8b2ae
2014/12/31 14:52:10 raft: ce2a822cea30bfca became follower at term 0
2014/12/31 14:52:10 raft: newRaft ce2a822cea30bfca [peers: [], term: 0, commit: 0, lastindex: 0, lastterm: 0]
2014/12/31 14:52:10 raft: ce2a822cea30bfca became follower at term 1
2014/12/31 14:52:10 etcdserver: added local member ce2a822cea30bfca [http://localhost:2380 http://localhost:7001] to cluster 7e27652122e8b2ae
2014/12/31 14:52:11 raft: ce2a822cea30bfca is starting a new election at term 1
2014/12/31 14:52:11 raft: ce2a822cea30bfca became candidate at term 2
2014/12/31 14:52:11 raft: ce2a822cea30bfca received vote from ce2a822cea30bfca at term 2
2014/12/31 14:52:11 raft: ce2a822cea30bfca became leader at term 2
2014/12/31 14:52:11 raft.node: ce2a822cea30bfca elected leader ce2a822cea30bfca at term 2
2014/12/31 14:52:11 etcdserver: published {Name:default ClientURLs:[http://localhost:2379 http://localhost:4001]} to cluster 7e27652122e8b2ae
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，可以使用 etcdctl 命令进行测试，设置和获取键值 testkey: &amp;laquo;hello world&amp;raquo;，检查 etcd 服务是否启动成功：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./etcdctl set testkey &amp;quot;hello world&amp;quot;
hello world
$ ./etcdctl get testkey
hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明 etcd 服务已经成功启动了。&lt;/p&gt;

&lt;p&gt;当然，也可以通过 HTTP 访问本地 2379 或 4001 端口的方式来进行操作，例如查看 testkey 的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -L http://localhost:4001/v2/keys/testkey
{&amp;quot;action&amp;quot;:&amp;quot;get&amp;quot;,&amp;quot;node&amp;quot;:{&amp;quot;key&amp;quot;:&amp;quot;/testkey&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;hello world&amp;quot;,&amp;quot;modifiedIndex&amp;quot;:3,&amp;quot;createdIndex&amp;quot;:3}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;docker-镜像方式下载&#34;&gt;Docker 镜像方式下载&lt;/h3&gt;

&lt;p&gt;镜像名称为 quay.io/coreos/etcd:v2.0.0_rc.1，可以通过下面的命令启动 etcd 服务监听到 4001 端口。&lt;br /&gt;
&lt;code&gt;$ sudo docker run -p 4001:4001 -v /etc/ssl/certs/:/etc/ssl/certs/ quay.io/coreos/etcd:v2.0.0_rc.1&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vagrant建立快照</title>
      <link>http://wixb50.coding.me/2015/11/03/vagrant%E5%BB%BA%E7%AB%8B%E5%BF%AB%E7%85%A7/</link>
      <pubDate>Tue, 03 Nov 2015 12:45:55 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.coding.me/2015/11/03/vagrant%E5%BB%BA%E7%AB%8B%E5%BF%AB%E7%85%A7/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;使用Vagrant的快照功能可以很方便快速的创建当前虚拟机的一个临时备份状态，在进行重要操作时可以先创建一个快照以便在操作失误后快速恢复。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装Vagrant快照插件：&lt;br /&gt;
&lt;code&gt;vagrant plugin install vagrant-multiprovider-snap&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant snap
Usage: vagrant snap &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]

Available subcommands:
     back
     delete
     go
     list
     take

For help on any individual command run `vagrant snapshot &amp;lt;command&amp;gt; -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个快照&lt;br /&gt;
&lt;code&gt;vagrant snapshot take &amp;quot;Name&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看快照列表&lt;br /&gt;
&lt;code&gt;vagrant snapshot list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从指定快照中恢复&lt;br /&gt;
&lt;code&gt;vagrant snapshot go &amp;quot;Name&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除一个快照&lt;br /&gt;
&lt;code&gt;vagrant snapshot delete &amp;quot;Name&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;一些参考资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://segmentfault.com/a/1190000000264347&#34;&gt;使用 Vagrant 打造跨平台开发环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.williamsang.com/archives/2401.html&#34;&gt;Vagrant 三种网络配置详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Vagrant常用命令</title>
      <link>http://wixb50.coding.me/2015/11/03/vagrant%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 03 Nov 2015 11:45:55 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.coding.me/2015/11/03/vagrant%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>

&lt;h2 id=&#34;vagrant常用命令:7846872d314dab4b0ed8e0de546c9a09&#34;&gt;Vagrant常用命令&lt;/h2&gt;

&lt;p&gt;前面讲了Vagrant的几个命令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vagrant box add {title} {url}&lt;/code&gt; 添加box的操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vagrant init {title}&lt;/code&gt; 初始化box的操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vagrant up&lt;/code&gt; 启动虚拟机的操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vagrant ssh&lt;/code&gt; 登录拟机的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vagrant还包括如下一些操作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant box list&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;显示当前已经添加的box列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant box list
base (virtualbox)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant box remove&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;删除相应的box&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant box remove base virtualbox
Removing box &#39;base&#39; with provider &#39;virtualbox&#39;...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant destroy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;停止当前正在运行的虚拟机并销毁所有创建的资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant destroy
Are you sure you want to destroy the &#39;default&#39; VM? [y/N] y
[default] Destroying VM and associated drives...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant halt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant halt
[default] Attempting graceful shutdown of VM...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant package&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打包命令，可以把当前的运行的虚拟机环境进行打包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant package
[default] Attempting graceful shutdown of VM...
[default] Clearing any previously set forwarded ports...
[default] Creating temporary directory for export...
[default] Exporting VM...
[default] Compressing package to: /Users/astaxie/vagrant/package.box
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant plugin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用于安装卸载插件&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant provision&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通常情况下Box只做最基本的设置，而不是设置好所有的环境，因此Vagrant通常使用Chef或者Puppet来做进一步的环境搭建。那么Chef或者Puppet称为provisioning，而该命令就是指定开启相应的provisioning。按照Vagrant作者的说法，所谓的provisioning就是&amp;raquo;The problem of installing software on a booted system&amp;raquo;的意思。除了Chef和Puppet这些主流的配置管理工具之外，我们还可以使用Shell来编写安装脚本。&lt;/p&gt;

&lt;p&gt;例如： &lt;code&gt;vagrant provision --provision-with chef&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant reload&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;重新启动虚拟机，主要用于重新载入配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant reload
[default] Attempting graceful shutdown of VM...
[default] Setting the name of the VM...
[default] Clearing any previously set forwarded ports...
[default] Creating shared folders metadata...
[default] Clearing any previously set network interfaces...
[default] Preparing network interfaces based on configuration...
[default] Forwarding ports...
[default] -- 22 =&amp;gt; 2222 (adapter 1)
[default] Booting VM...
[default] Waiting for VM to boot. This can take a few minutes.
[default] VM booted and ready for use!
[default] Setting hostname...
[default] Mounting shared folders...
[default] -- /vagrant
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant resume&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;恢复前面被挂起的状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$vagrant resume
[default] Resuming suspended VM...
[default] Booting VM...
[default] Waiting for VM to boot. This can take a few minutes.
[default] VM booted and ready for use!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant ssh-config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;输出用于ssh连接的一些信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$vagrant ssh-config
Host default
  HostName 127.0.0.1
  User vagrant
  Port 2222
  UserKnownHostsFile /dev/null
  StrictHostKeyChecking no
  PasswordAuthentication no
  IdentityFile &amp;quot;/Users/astaxie/.vagrant.d/insecure_private_key&amp;quot;
  IdentitiesOnly yes
  LogLevel FATAL
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant status&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;获取当前虚拟机的状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$vagrant status
Current machine states:


default                   running (virtualbox)


The VM is running. To stop this VM, you can run `vagrant halt` to
shut it down forcefully, or you can run `vagrant suspend` to simply
suspend the virtual machine. In either case, to restart it again,
simply run `vagrant up`.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vagrant suspend&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;挂起当前的虚拟机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant suspend
[default] Saving VM state and suspending execution...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;模拟打造多机器的分布式系统:7846872d314dab4b0ed8e0de546c9a09&#34;&gt;模拟打造多机器的分布式系统&lt;/h2&gt;

&lt;p&gt;前面这些单主机单虚拟机主要是用来自己做开发机，从这部分开始的内容主要将向大家介绍如何在单机上通过虚拟机来打造分布式造集群系统。这种多机器模式特别适合以下几种人：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;快速建立产品网络的多机器环境，例如web服务器、db服务器&lt;/li&gt;
&lt;li&gt;建立一个分布式系统，学习他们是如何交互的&lt;/li&gt;
&lt;li&gt;测试API和其他组件的通信&lt;/li&gt;
&lt;li&gt;容灾模拟，网络断网、机器死机、连接超时等情况&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Vagrant支持单机模拟多台机器，而且支持一个配置文件Vagrntfile就可以跑分布式系统。&lt;/p&gt;

&lt;p&gt;现在我们来建立多台VM跑起來，並且让他们之间能够相通信，假设一台是应用服务器、一台是DB服务器，那么这个结构在Vagrant中非常简单，其实和单台的配置差不多，你只需要通过&lt;code&gt;config.vm.define&lt;/code&gt;来定义不同的角色就可以了，现在我们打开配置文件进行如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Vagrant.configure(&amp;quot;2&amp;quot;) do |config|
  config.vm.define :web do |web|
    web.vm.provider &amp;quot;virtualbox&amp;quot; do |v|
          v.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--name&amp;quot;, &amp;quot;web&amp;quot;, &amp;quot;--memory&amp;quot;, &amp;quot;512&amp;quot;]
    end
    web.vm.box = &amp;quot;base&amp;quot;
    web.vm.hostname = &amp;quot;web&amp;quot;
    web.vm.network :private_network, ip: &amp;quot;11.11.1.1&amp;quot;
  end

  config.vm.define :db do |db|
    db.vm.provider &amp;quot;virtualbox&amp;quot; do |v|
          v.customize [&amp;quot;modifyvm&amp;quot;, :id, &amp;quot;--name&amp;quot;, &amp;quot;db&amp;quot;, &amp;quot;--memory&amp;quot;, &amp;quot;512&amp;quot;]
    end
    db.vm.box = &amp;quot;base&amp;quot;
    db.vm.hostname = &amp;quot;db&amp;quot;
    db.vm.network :private_network, ip: &amp;quot;11.11.1.2&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的设置和前面我们单机设置配置类似，只是我们使用了&lt;code&gt;:web&lt;/code&gt;以及&lt;code&gt;:db&lt;/code&gt;分別做了两个VM的设置，并且给每个VM设置了不同的&lt;code&gt;hostname&lt;/code&gt;和IP，设置好之后再使用&lt;code&gt;vagrant up&lt;/code&gt;将虚拟机跑起来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant up
Bringing machine &#39;web&#39; up with &#39;virtualbox&#39; provider...
Bringing machine &#39;db&#39; up with &#39;virtualbox&#39; provider...
[web] Setting the name of the VM...
[web] Clearing any previously set forwarded ports...
[web] Creating shared folders metadata...
[web] Clearing any previously set network interfaces...
[web] Preparing network interfaces based on configuration...
[web] Forwarding ports...
[web] -- 22 =&amp;gt; 2222 (adapter 1)
[web] Running any VM customizations...
[web] Booting VM...
[web] Waiting for VM to boot. This can take a few minutes.
[web] VM booted and ready for use!
[web] Setting hostname...
[web] Configuring and enabling network interfaces...
[web] Mounting shared folders...
[web] -- /vagrant
[db] Setting the name of the VM...
[db] Clearing any previously set forwarded ports...
[db] Fixed port collision for 22 =&amp;gt; 2222. Now on port 2200.
[db] Creating shared folders metadata...
[db] Clearing any previously set network interfaces...
[db] Preparing network interfaces based on configuration...
[db] Forwarding ports...
[db] -- 22 =&amp;gt; 2200 (adapter 1)
[db] Running any VM customizations...
[db] Booting VM...
[db] Waiting for VM to boot. This can take a few minutes.
[db] VM booted and ready for use!
[db] Setting hostname...
[db] Configuring and enabling network interfaces...
[db] Mounting shared folders...
[db] -- /vagrant
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到上面的信息输出后，我们就可以通过&lt;code&gt;vagrant ssh&lt;/code&gt;登录虚拟机了，但是这次和上次使用的不一样了，这次我们需要指定相应的角色，用来告诉ssh你期望连接的是哪一台：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant ssh web
vagrant@web:~$

$ vagrant ssh db
vagrant@db:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很酷！现在接下来我们再来验证一下虚拟机之间的通信，让我们先使用ssh登录web虚拟机，然后在web虚拟机上使用ssh登录db虚拟机(默认密码是&lt;code&gt;vagrant&lt;/code&gt;)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vagrant ssh web
Linux web 2.6.32-38-server #83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/Linux
Ubuntu 10.04.4 LTS

Welcome to the Ubuntu Server!
 * Documentation:  http://www.ubuntu.com/server/doc
New release &#39;precise&#39; available.
Run &#39;do-release-upgrade&#39; to upgrade to it.

Welcome to your Vagrant-built virtual machine.
Last login: Thu Aug  8 18:55:44 2013 from 10.0.2.2
vagrant@web:~$ ssh 11.11.1.2
The authenticity of host &#39;11.11.1.2 (11.11.1.2)&#39; can&#39;t be established.
RSA key fingerprint is e7:8f:07:57:69:08:6e:fa:82:bc:1c:f6:53:3f:12:9e.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &#39;11.11.1.2&#39; (RSA) to the list of known hosts.
vagrant@11.11.1.2&#39;s password:
Linux db 2.6.32-38-server #83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/Linux
Ubuntu 10.04.4 LTS

Welcome to the Ubuntu Server!
 * Documentation:  http://www.ubuntu.com/server/doc
New release &#39;precise&#39; available.
Run &#39;do-release-upgrade&#39; to upgrade to it.

Welcome to your Vagrant-built virtual machine.
Last login: Thu Aug  8 18:58:50 2013 from 10.0.2.2
vagrant@db:~$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面的信息我们可以看到虚拟机之间通信是畅通的，所以现在开始你伟大的架构设计吧，你想设计怎么样的架构都可以，唯一限制你的就是你主机的硬件配置了。&lt;/p&gt;

&lt;h2 id=&#34;links:7846872d314dab4b0ed8e0de546c9a09&#34;&gt;links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;preface.md&#34;&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;上一节: &lt;a href=&#34;01.2.md&#34;&gt;Vagrant安装配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下一节: &lt;a href=&#34;01.4.md&#34;&gt;Go环境安装配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>docker安装与配置</title>
      <link>http://wixb50.coding.me/2015/11/02/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 02 Nov 2015 21:38:38 +0800</pubDate>
      <author>wixb50@gmail.com (Wixb)</author>
      <guid>http://wixb50.coding.me/2015/11/02/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>

&lt;h3 id=&#34;方法一-安装命令:a3a6e387cbc471e9a108d854770f0455&#34;&gt;方法一：安装命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install apt-transport-https
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
sudo bash -c &amp;quot;echo deb https://get.docker.io/ubuntu docker main &amp;gt; /etc/apt/sources.list.d/docker.list&amp;quot;
sudo apt-get update
sudo apt-get install lxc-docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法二-安装命令-推荐:a3a6e387cbc471e9a108d854770f0455&#34;&gt;方法二：安装命令(推荐)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl -sSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完&lt;/p&gt;

&lt;h3 id=&#34;docker资料收集:a3a6e387cbc471e9a108d854770f0455&#34;&gt;Docker资料收集&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@gargar454/deploy-a-mesos-cluster-with-7-commands-using-docker-57951e020586#.74cyoyjp5&#34;&gt;Deploy a Mesos Cluster with 7 Commands Using Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://technologyconversations.com/2015/11/04/docker-clustering-tools-compared-kubernetes-vs-docker-swarm/&#34;&gt;Docker Clustering Tools Compared: Kubernetes vs Docker Swarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mesosphere.com/blog/2014/11/10/docker-on-mesos-with-marathon/&#34;&gt;DOCKER CLUSTERING ON MESOS WITH MARATHON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.tuicool.com/articles/nyyENrY&#34;&gt;Swarm、Fleet、Kubernetes和Mesos的比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>